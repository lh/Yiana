diff --git a/.gitignore b/.gitignore
index a8576c6..b8b7ebc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -90,4 +90,8 @@ fastlane/test_output
 iOSInjectionProject/
 
 # macOS
-.DS_Store
\ No newline at end of file
+.DS_Store
+
+# Debug PDF sync logs
+temp-debug-files/debug-pdf-sync.log
+temp-debug-files/debug-pdf-sync.error.log
\ No newline at end of file
diff --git a/Yiana/Yiana/Assets.xcassets/AccentColor.colorset/Contents.json b/Yiana/Yiana/Assets.xcassets/AccentColor.colorset/Contents.json
index eb87897..679436b 100644
--- a/Yiana/Yiana/Assets.xcassets/AccentColor.colorset/Contents.json
+++ b/Yiana/Yiana/Assets.xcassets/AccentColor.colorset/Contents.json
@@ -1,7 +1,16 @@
 {
   "colors" : [
     {
-      "idiom" : "universal"
+      "idiom" : "universal",
+      "color" : {
+        "color-space" : "srgb",
+        "components" : {
+          "red" : "0.000",
+          "green" : "0.478",
+          "blue" : "1.000",
+          "alpha" : "1.000"
+        }
+      }
     }
   ],
   "info" : {
diff --git a/Yiana/Yiana/Assets.xcassets/HeadingColor.colorset/Contents.json b/Yiana/Yiana/Assets.xcassets/HeadingColor.colorset/Contents.json
new file mode 100644
index 0000000..eafe627
--- /dev/null
+++ b/Yiana/Yiana/Assets.xcassets/HeadingColor.colorset/Contents.json
@@ -0,0 +1,20 @@
+{
+  "colors": [
+    {
+      "idiom": "universal",
+      "color": {
+        "color-space": "srgb",
+        "components": {
+          "red": "0.000",
+          "green": "0.000",
+          "blue": "0.000",
+          "alpha": "1.000"
+        }
+      }
+    }
+  ],
+  "info": {
+    "author": "xcode",
+    "version": 1
+  }
+}
\ No newline at end of file
diff --git a/Yiana/Yiana/Assets.xcassets/ListMarkerColor.colorset/Contents.json b/Yiana/Yiana/Assets.xcassets/ListMarkerColor.colorset/Contents.json
new file mode 100644
index 0000000..eafe627
--- /dev/null
+++ b/Yiana/Yiana/Assets.xcassets/ListMarkerColor.colorset/Contents.json
@@ -0,0 +1,20 @@
+{
+  "colors": [
+    {
+      "idiom": "universal",
+      "color": {
+        "color-space": "srgb",
+        "components": {
+          "red": "0.000",
+          "green": "0.000",
+          "blue": "0.000",
+          "alpha": "1.000"
+        }
+      }
+    }
+  ],
+  "info": {
+    "author": "xcode",
+    "version": 1
+  }
+}
\ No newline at end of file
diff --git a/Yiana/Yiana/ContentView.swift b/Yiana/Yiana/ContentView.swift
index 05e3302..3ad5abc 100644
--- a/Yiana/Yiana/ContentView.swift
+++ b/Yiana/Yiana/ContentView.swift
@@ -7,6 +7,9 @@
 
 import SwiftUI
 import PDFKit
+#if os(macOS)
+import AppKit
+#endif
 
 struct ContentView: View {
     @EnvironmentObject var importHandler: DocumentImportHandler
@@ -18,6 +21,7 @@ struct ContentView: View {
 
     var body: some View {
         DocumentListView()
+            .tint(Color("AccentColor"))
             .sheet(isPresented: $importHandler.showingImportDialog) {
                 ImportPDFView(
                     pdfURL: importHandler.pdfToImport,
diff --git a/Yiana/Yiana/Models/DocumentMetadata.swift b/Yiana/Yiana/Models/DocumentMetadata.swift
index 3011ceb..098bab3 100644
--- a/Yiana/Yiana/Models/DocumentMetadata.swift
+++ b/Yiana/Yiana/Models/DocumentMetadata.swift
@@ -32,7 +32,10 @@ struct DocumentMetadata: Codable, Equatable {
 
     /// Full text extracted from the document via OCR
     var fullText: String?
-    
+
+    /// Whether the document has an in-progress text page draft
+    var hasPendingTextPage: Bool
+
     init(
         id: UUID,
         title: String,
@@ -41,7 +44,8 @@ struct DocumentMetadata: Codable, Equatable {
         pageCount: Int,
         tags: [String],
         ocrCompleted: Bool,
-        fullText: String? = nil
+        fullText: String? = nil,
+        hasPendingTextPage: Bool = false
     ) {
         self.id = id
         self.title = title
@@ -51,5 +55,46 @@ struct DocumentMetadata: Codable, Equatable {
         self.tags = tags
         self.ocrCompleted = ocrCompleted
         self.fullText = fullText
+        self.hasPendingTextPage = hasPendingTextPage
+    }
+
+    private enum CodingKeys: String, CodingKey {
+        case id
+        case title
+        case created
+        case modified
+        case pageCount
+        case tags
+        case ocrCompleted
+        case fullText
+        case hasPendingTextPage
+    }
+
+    init(from decoder: Decoder) throws {
+        let container = try decoder.container(keyedBy: CodingKeys.self)
+        self.id = try container.decode(UUID.self, forKey: .id)
+        self.title = try container.decode(String.self, forKey: .title)
+        self.created = try container.decode(Date.self, forKey: .created)
+        self.modified = try container.decode(Date.self, forKey: .modified)
+        self.pageCount = try container.decode(Int.self, forKey: .pageCount)
+        self.tags = try container.decode([String].self, forKey: .tags)
+        self.ocrCompleted = try container.decode(Bool.self, forKey: .ocrCompleted)
+        self.fullText = try container.decodeIfPresent(String.self, forKey: .fullText)
+        self.hasPendingTextPage = try container.decodeIfPresent(Bool.self, forKey: .hasPendingTextPage) ?? false
+    }
+
+    func encode(to encoder: Encoder) throws {
+        var container = encoder.container(keyedBy: CodingKeys.self)
+        try container.encode(id, forKey: .id)
+        try container.encode(title, forKey: .title)
+        try container.encode(created, forKey: .created)
+        try container.encode(modified, forKey: .modified)
+        try container.encode(pageCount, forKey: .pageCount)
+        try container.encode(tags, forKey: .tags)
+        try container.encode(ocrCompleted, forKey: .ocrCompleted)
+        try container.encodeIfPresent(fullText, forKey: .fullText)
+        if hasPendingTextPage {
+            try container.encode(true, forKey: .hasPendingTextPage)
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/Yiana/Yiana/Models/NoteDocument.swift b/Yiana/Yiana/Models/NoteDocument.swift
index da4b8be..609db94 100644
--- a/Yiana/Yiana/Models/NoteDocument.swift
+++ b/Yiana/Yiana/Models/NoteDocument.swift
@@ -31,7 +31,8 @@ class NoteDocument: UIDocument {
             pageCount: 0,
             tags: [],
             ocrCompleted: false,
-            fullText: nil
+            fullText: nil,
+            hasPendingTextPage: false
         )
         super.init(fileURL: url)
     }
@@ -133,7 +134,8 @@ class NoteDocument: NSDocument {
             pageCount: 0,
             tags: [],
             ocrCompleted: false,
-            fullText: nil
+            fullText: nil,
+            hasPendingTextPage: false
         )
         super.init()
     }
@@ -212,4 +214,4 @@ class NoteDocument: NSDocument {
         return try decoder.decode(DocumentMetadata.self, from: metadataData)
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/Yiana/Yiana/Services/BackgroundIndexer.swift b/Yiana/Yiana/Services/BackgroundIndexer.swift
index 9e2fa4c..f61f454 100644
--- a/Yiana/Yiana/Services/BackgroundIndexer.swift
+++ b/Yiana/Yiana/Services/BackgroundIndexer.swift
@@ -48,121 +48,109 @@ class BackgroundIndexer: ObservableObject {
 
         print("ðŸ” Starting background document indexing...")
 
-        do {
-            // Get all documents recursively
-            let repository = DocumentRepository()
-            let allDocuments = repository.allDocumentsRecursive()
-
-            totalCount = allDocuments.count
-            print("ðŸ“š Found \(totalCount) documents to index")
-
-            // Check which documents are already indexed
-            var documentsToIndex: [(url: URL, metadata: DocumentMetadata)] = []
-
-            for item in allDocuments {
-                // Check if task was cancelled
-                if Task.isCancelled {
-                    print("âš ï¸ Indexing cancelled by user")
-                    isIndexing = false
-                    return
-                }
+        // Get all documents recursively
+        let repository = DocumentRepository()
+        let allDocuments = repository.allDocumentsRecursive()
+
+        totalCount = allDocuments.count
+        print("ðŸ“š Found \(totalCount) documents to index")
+
+        // Check which documents are already indexed
+        var documentsToIndex: [(url: URL, metadata: DocumentMetadata)] = []
+
+        for item in allDocuments {
+            // Check if task was cancelled
+            if Task.isCancelled {
+                print("âš ï¸ Indexing cancelled by user")
+                isIndexing = false
+                return
+            }
 
-                // Extract metadata
-                guard let metadata = try? NoteDocument.extractMetadata(from: item.url) else {
-                    continue
-                }
+            // Extract metadata
+            guard let metadata = try? NoteDocument.extractMetadata(from: item.url) else {
+                continue
+            }
 
-                // Check if already indexed
-                let isIndexed = (try? await searchIndex.isDocumentIndexed(id: metadata.id)) ?? false
+            // Check if already indexed
+            let isIndexed = (try? await searchIndex.isDocumentIndexed(id: metadata.id)) ?? false
 
-                if !isIndexed {
-                    documentsToIndex.append((url: item.url, metadata: metadata))
-                }
+            if !isIndexed {
+                documentsToIndex.append((url: item.url, metadata: metadata))
             }
+        }
 
-            print("ðŸ“ \(documentsToIndex.count) documents need indexing")
+        print("ðŸ“ \(documentsToIndex.count) documents need indexing")
 
-            // Index documents in batches to avoid overwhelming the system
-            let batchSize = 10
-            var corruptionDetected = false
+        // Index documents in batches to avoid overwhelming the system
+        let batchSize = 10
+        var corruptionDetected = false
 
-            for (index, item) in documentsToIndex.enumerated() {
-                // Check if task was cancelled
-                if Task.isCancelled {
-                    print("âš ï¸ Indexing cancelled by user")
-                    isIndexing = false
-                    return
-                }
+        for (index, item) in documentsToIndex.enumerated() {
+            // Check if task was cancelled
+            if Task.isCancelled {
+                print("âš ï¸ Indexing cancelled by user")
+                isIndexing = false
+                return
+            }
 
-                // Use fullText from metadata (already embedded in .yianazip file)
-                let fullText = item.metadata.fullText ?? ""
-
-                // Index the document
-                do {
-                    try await searchIndex.indexDocument(
-                        id: item.metadata.id,
-                        url: item.url,
-                        title: item.metadata.title,
-                        fullText: fullText,
-                        tags: item.metadata.tags,
-                        metadata: item.metadata
-                    )
-
-                    indexedCount += 1
-                    indexProgress = Double(indexedCount) / Double(documentsToIndex.count)
-
-                    if indexedCount % 10 == 0 {
-                        print("âœ“ Indexed \(indexedCount)/\(documentsToIndex.count) documents")
-                    }
-                } catch {
-                    let errorString = String(describing: error)
-                    if errorString.contains("index corruption") || errorString.contains("database disk image is malformed") {
-                        print("ðŸ”´ Database corruption detected!")
-                        corruptionDetected = true
-                        break
-                    }
-                    print("âš ï¸ Failed to index \(item.metadata.title): \(error)")
+            // Use fullText from metadata (already embedded in .yianazip file)
+            let fullText = item.metadata.fullText ?? ""
+
+            // Index the document
+            do {
+                try await searchIndex.indexDocument(
+                    id: item.metadata.id,
+                    url: item.url,
+                    title: item.metadata.title,
+                    fullText: fullText,
+                    tags: item.metadata.tags,
+                    metadata: item.metadata
+                )
+
+                indexedCount += 1
+                indexProgress = Double(indexedCount) / Double(documentsToIndex.count)
+
+                if indexedCount % 10 == 0 {
+                    print("âœ“ Indexed \(indexedCount)/\(documentsToIndex.count) documents")
                 }
-
-                // If corruption detected, stop indexing
-                if corruptionDetected {
+            } catch {
+                let errorString = String(describing: error)
+                if errorString.contains("index corruption") || errorString.contains("database disk image is malformed") {
+                    print("ðŸ”´ Database corruption detected!")
+                    corruptionDetected = true
                     break
                 }
-
-                // Small delay every batch to avoid blocking main thread
-                if (index + 1) % batchSize == 0 {
-                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 second
-                }
+                print("âš ï¸ Failed to index \(item.metadata.title): \(error)")
             }
 
-            // Handle database corruption
-            if corruptionDetected {
-                print("ðŸ”§ Attempting to recover from database corruption...")
-                do {
-                    try await searchIndex.resetDatabase()
-                    print("âœ“ Database reset successful - restarting indexing")
-                    // Restart indexing after reset
-                    indexAllDocuments()
-                    return
-                } catch {
-                    print("âŒ Failed to reset database: \(error)")
-                }
+            // Small delay every batch to avoid blocking main thread
+            if (index + 1) % batchSize == 0 {
+                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 second
             }
+        }
 
-            // Optimize the index after bulk indexing
-            if documentsToIndex.count > 0 {
-                print("ðŸ”§ Optimizing search index...")
-                try? await searchIndex.optimize()
+        // Handle database corruption
+        if corruptionDetected {
+            print("ðŸ”§ Attempting to recover from database corruption...")
+            if (try? await searchIndex.resetDatabase()) != nil {
+                print("âœ“ Database reset successful - restarting indexing")
+                indexAllDocuments()
+                return
+            } else {
+                print("âŒ Failed to reset database")
             }
+        }
 
-            print("âœ… Background indexing complete: \(indexedCount) documents indexed")
-
-        } catch {
-            print("âŒ Background indexing failed: \(error)")
+        // Optimize the index after bulk indexing
+        if documentsToIndex.count > 0 {
+            print("ðŸ”§ Optimizing search index...")
+            try? await searchIndex.optimize()
         }
 
+        print("âœ… Background indexing complete: \(indexedCount) documents indexed")
+
         isIndexing = false
         indexProgress = 1.0
     }
 
-}
\ No newline at end of file
+}
diff --git a/Yiana/Yiana/Services/ImportService.swift b/Yiana/Yiana/Services/ImportService.swift
index e366c58..e9a552d 100644
--- a/Yiana/Yiana/Services/ImportService.swift
+++ b/Yiana/Yiana/Services/ImportService.swift
@@ -72,7 +72,8 @@ class ImportService {
             pageCount: pageCount,
             tags: [],
             ocrCompleted: false,
-            fullText: nil
+            fullText: nil,
+            hasPendingTextPage: false
         )
 
         let encoder = JSONEncoder()
@@ -146,7 +147,8 @@ class ImportService {
             pageCount: metadata.pageCount,
             tags: metadata.tags,
             ocrCompleted: false,
-            fullText: metadata.fullText
+            fullText: metadata.fullText,
+            hasPendingTextPage: metadata.hasPendingTextPage
         )
 
         let newMetadataData = try JSONEncoder().encode(updatedMetadata)
@@ -182,4 +184,3 @@ class ImportService {
         }
     }
 }
-
diff --git a/Yiana/Yiana/Services/TextPageDraftManager.swift b/Yiana/Yiana/Services/TextPageDraftManager.swift
new file mode 100644
index 0000000..724d9b6
--- /dev/null
+++ b/Yiana/Yiana/Services/TextPageDraftManager.swift
@@ -0,0 +1,152 @@
+//
+//  TextPageDraftManager.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Handles storage and retrieval of text page drafts that live alongside
+//  .yianazip documents. Drafts are stored as Markdown in a hidden sidecar
+//  directory so that iCloud sync keeps them available across devices without
+//  inflating the primary metadata payload.
+//
+
+import Foundation
+
+/// Persisted metadata for a text page draft.
+struct TextPageDraftMetadata: Codable, Equatable {
+    var updatedAt: Date
+    var cursorPosition: Int?
+
+    init(updatedAt: Date = Date(), cursorPosition: Int? = nil) {
+        self.updatedAt = updatedAt
+        self.cursorPosition = cursorPosition
+    }
+}
+
+/// Combined payload returned by the draft manager.
+struct TextPageDraft: Equatable {
+    var content: String
+    var metadata: TextPageDraftMetadata
+}
+
+/// Actor that manages disk IO for text page drafts.
+actor TextPageDraftManager {
+    static let shared = TextPageDraftManager()
+
+    private let fileManager = FileManager.default
+    private let draftsDirectoryName = ".text-drafts"
+    private let markdownExtension = "md"
+    private let metadataExtension = "meta"
+
+    // MARK: - Paths
+
+    private func draftsDirectory(for documentURL: URL) -> URL {
+        documentURL
+            .deletingLastPathComponent()
+            .appendingPathComponent(draftsDirectoryName, isDirectory: true)
+    }
+
+    private func baseFileName(for metadata: DocumentMetadata) -> String {
+        metadata.id.uuidString.lowercased()
+    }
+
+    private func draftContentURL(for documentURL: URL, metadata: DocumentMetadata) -> URL {
+        draftsDirectory(for: documentURL)
+            .appendingPathComponent(baseFileName(for: metadata))
+            .appendingPathExtension(markdownExtension)
+    }
+
+    private func draftMetadataURL(for documentURL: URL, metadata: DocumentMetadata) -> URL {
+        draftsDirectory(for: documentURL)
+            .appendingPathComponent(baseFileName(for: metadata))
+            .appendingPathExtension(metadataExtension)
+    }
+
+    // MARK: - Public API
+
+    func hasDraft(for documentURL: URL, metadata: DocumentMetadata) -> Bool {
+        fileManager.fileExists(atPath: draftContentURL(for: documentURL, metadata: metadata).path)
+    }
+
+    func loadDraft(for documentURL: URL, metadata: DocumentMetadata) -> TextPageDraft? {
+        let contentURL = draftContentURL(for: documentURL, metadata: metadata)
+        guard let contentData = try? Data(contentsOf: contentURL),
+              let content = String(data: contentData, encoding: .utf8) else {
+            return nil
+        }
+
+        let metadataURL = draftMetadataURL(for: documentURL, metadata: metadata)
+        let draftMetadata: TextPageDraftMetadata
+
+        if let metaData = try? Data(contentsOf: metadataURL) {
+            let decoder = JSONDecoder()
+            if let decoded = try? decoder.decode(TextPageDraftMetadata.self, from: metaData) {
+                draftMetadata = decoded
+            } else {
+            draftMetadata = TextPageDraftMetadata(updatedAt: fileManager.modificationDate(for: contentURL) ?? Date())
+        }
+        } else {
+            draftMetadata = TextPageDraftMetadata(updatedAt: fileManager.modificationDate(for: contentURL) ?? Date())
+        }
+
+        return TextPageDraft(content: content, metadata: draftMetadata)
+    }
+
+    func saveDraft(_ draft: TextPageDraft, for documentURL: URL, metadata: DocumentMetadata) throws {
+        let directory = draftsDirectory(for: documentURL)
+        try ensureDirectoryExists(directory)
+
+        let contentURL = draftContentURL(for: documentURL, metadata: metadata)
+        let metadataURL = draftMetadataURL(for: documentURL, metadata: metadata)
+
+        let contentData = Data(draft.content.utf8)
+        try contentData.write(to: contentURL, options: .atomic)
+
+        let encoder = JSONEncoder()
+        encoder.outputFormatting = [.prettyPrinted]
+        let metaData = try encoder.encode(draft.metadata)
+        try metaData.write(to: metadataURL, options: .atomic)
+    }
+
+    func updateDraftContent(_ content: String, for documentURL: URL, metadata: DocumentMetadata, cursorPosition: Int?) throws {
+        let draft = TextPageDraft(
+            content: content,
+            metadata: TextPageDraftMetadata(updatedAt: Date(), cursorPosition: cursorPosition)
+        )
+        try saveDraft(draft, for: documentURL, metadata: metadata)
+    }
+
+    func removeDraft(for documentURL: URL, metadata: DocumentMetadata) throws {
+        let contentURL = draftContentURL(for: documentURL, metadata: metadata)
+        let metadataURL = draftMetadataURL(for: documentURL, metadata: metadata)
+
+        if fileManager.fileExists(atPath: contentURL.path) {
+            try fileManager.removeItem(at: contentURL)
+        }
+
+        if fileManager.fileExists(atPath: metadataURL.path) {
+            try fileManager.removeItem(at: metadataURL)
+        }
+    }
+
+    func removeAllDrafts(in documentsDirectory: URL) throws {
+        let directory = documentsDirectory.appendingPathComponent(draftsDirectoryName, isDirectory: true)
+        if fileManager.fileExists(atPath: directory.path) {
+            try fileManager.removeItem(at: directory)
+        }
+    }
+
+    // MARK: - Helpers
+
+    private func ensureDirectoryExists(_ url: URL) throws {
+        if !fileManager.fileExists(atPath: url.path) {
+            try fileManager.createDirectory(at: url, withIntermediateDirectories: true)
+        }
+    }
+}
+
+private extension FileManager {
+    func modificationDate(for url: URL) -> Date? {
+        ((try? attributesOfItem(atPath: url.path))?[.modificationDate]) as? Date
+    }
+}
diff --git a/Yiana/Yiana/Services/TextPageLayoutSettings.swift b/Yiana/Yiana/Services/TextPageLayoutSettings.swift
new file mode 100644
index 0000000..02cc836
--- /dev/null
+++ b/Yiana/Yiana/Services/TextPageLayoutSettings.swift
@@ -0,0 +1,63 @@
+//
+//  TextPageLayoutSettings.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Stores user preferences for rendered text page layout, such as the
+//  default paper size when generating PDF pages from Markdown. A4 is the
+//  default, with the option to switch to US Letter for the North American
+//  market.
+//
+
+import Foundation
+import CoreGraphics
+
+enum TextPagePaperSize: String, CaseIterable, Identifiable, Codable {
+    case a4
+    case usLetter
+
+    var id: String { rawValue }
+
+    var displayName: String {
+        switch self {
+        case .a4:
+            return "A4"
+        case .usLetter:
+            return "US Letter"
+        }
+    }
+
+    /// Size in points at 72 DPI.
+    var size: CGSize {
+        switch self {
+        case .a4:
+            return CGSize(width: 595.2, height: 841.8) // 210mm Ã— 297mm
+        case .usLetter:
+            return CGSize(width: 612.0, height: 792.0) // 8.5" Ã— 11"
+        }
+    }
+}
+
+actor TextPageLayoutSettings {
+    static let shared = TextPageLayoutSettings()
+
+    private let defaults: UserDefaults
+    private let paperSizeKey = "textPage.preferredPaperSize"
+
+    init(defaults: UserDefaults = .standard) {
+        self.defaults = defaults
+    }
+
+    func preferredPaperSize() -> TextPagePaperSize {
+        if let rawValue = defaults.string(forKey: paperSizeKey),
+           let stored = TextPagePaperSize(rawValue: rawValue) {
+            return stored
+        }
+        return .a4
+    }
+
+    func setPreferredPaperSize(_ paperSize: TextPagePaperSize) {
+        defaults.set(paperSize.rawValue, forKey: paperSizeKey)
+    }
+}
diff --git a/Yiana/Yiana/Services/TextPagePDFRenderer.swift b/Yiana/Yiana/Services/TextPagePDFRenderer.swift
new file mode 100644
index 0000000..2b5d8d5
--- /dev/null
+++ b/Yiana/Yiana/Services/TextPagePDFRenderer.swift
@@ -0,0 +1,301 @@
+//
+//  TextPagePDFRenderer.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Renders Markdown content into a single PDF page (with spillover support)
+//  using a consistent layout tuned for medical note appendices. The renderer
+//  applies the same typography on both iOS and macOS, producing data suitable
+//  for appending to an existing PDF document.
+//
+
+import Foundation
+import CoreGraphics
+import PDFKit
+
+#if os(iOS)
+import UIKit
+#else
+import AppKit
+#endif
+
+private extension NSAttributedString.Key {
+    static var yianaInlinePresentation: NSAttributedString.Key {
+        if #available(iOS 15.0, macOS 12.0, *) {
+            return NSAttributedString.Key("NSInlinePresentationIntentAttributeName")
+        } else {
+            return NSAttributedString.Key("NSInlinePresentationIntentAttributeName")
+        }
+    }
+
+    static var yianaPresentation: NSAttributedString.Key {
+        if #available(iOS 15.0, macOS 12.0, *) {
+            return NSAttributedString.Key("NSPresentationIntentAttributeName")
+        } else {
+            return NSAttributedString.Key("NSPresentationIntentAttributeName")
+        }
+    }
+}
+
+struct TextPageRenderOutput {
+    let pdfData: Data
+    let plainText: String
+}
+
+struct TextPageRenderOptions {
+    var paperSize: CGSize
+    var insets: TextPageEdgeInsets
+    var headerFont: PlatformFont
+    var bodyFont: PlatformFont
+    var boldFont: PlatformFont
+    var italicFont: PlatformFont
+    var monoFont: PlatformFont
+    var headerColor:PlatformColor
+    var bodyColor: PlatformColor
+    var secondaryColor: PlatformColor
+    var accentColor: PlatformColor
+    var lineSpacing: CGFloat
+    var paragraphSpacing: CGFloat
+    var headerSpacing: CGFloat
+
+    static func `default`(for paperSize: TextPagePaperSize) -> TextPageRenderOptions {
+        let size = paperSize.size
+        let columnWidth: CGFloat = 432 // 6 inches at 72 DPI
+        let horizontalPadding = max(24, (size.width - columnWidth) / 2)
+        let insets = TextPageEdgeInsets(top: 72, left: horizontalPadding, bottom: 64, right: horizontalPadding)
+
+        #if os(iOS)
+        let bodyFont = UIFont.preferredFont(forTextStyle: .body)
+        let headerFont = UIFont.preferredFont(forTextStyle: .headline).withSize(bodyFont.pointSize * 0.9)
+        let boldFont = UIFont(descriptor: bodyFont.fontDescriptor.withSymbolicTraits(.traitBold) ?? bodyFont.fontDescriptor, size: bodyFont.pointSize)
+        let italicFont = UIFont(descriptor: bodyFont.fontDescriptor.withSymbolicTraits(.traitItalic) ?? bodyFont.fontDescriptor, size: bodyFont.pointSize)
+        let monoFont = UIFont.monospacedSystemFont(ofSize: bodyFont.pointSize * 0.95, weight: .regular)
+        let headerColor = UIColor.darkGray
+        let bodyColor = UIColor.black
+        let secondaryColor = UIColor.gray
+        let accentColor = TextPageBrand.accentColor
+        #else
+        let bodyFont = NSFont.preferredFont(forTextStyle: .body)
+        let headerFont = NSFont.preferredFont(forTextStyle: .headline)
+        let fontManager = NSFontManager.shared
+        let boldFont = fontManager.convert(bodyFont, toHaveTrait: .boldFontMask)
+        let italicFont = fontManager.convert(bodyFont, toHaveTrait: .italicFontMask)
+        let monoFont = NSFont.monospacedSystemFont(ofSize: bodyFont.pointSize * 0.95, weight: .regular)
+        let headerColor = NSColor.secondaryLabelColor
+        let bodyColor = NSColor.textColor
+        let secondaryColor = NSColor.secondaryLabelColor
+        let accentColor = TextPageBrand.accentColor
+        #endif
+
+        return TextPageRenderOptions(
+            paperSize: size,
+            insets: insets,
+            headerFont: headerFont,
+            bodyFont: bodyFont,
+            boldFont: boldFont,
+            italicFont: italicFont,
+            monoFont: monoFont,
+            headerColor: headerColor,
+            bodyColor: bodyColor,
+            secondaryColor: secondaryColor,
+            accentColor: accentColor,
+            lineSpacing: 4,
+            paragraphSpacing: bodyFont.pointSize * 0.5,
+            headerSpacing: 24
+        )
+    }
+}
+
+struct TextPageEdgeInsets {
+    var top: CGFloat
+    var left: CGFloat
+    var bottom: CGFloat
+    var right: CGFloat
+}
+
+final class TextPagePDFRenderer {
+
+    func render(markdown: String, headerText: String, options: TextPageRenderOptions) throws -> TextPageRenderOutput {
+        let markdownResult = makeBodyAttributedString(from: markdown, options: options)
+        let bodyAttributed = markdownResult.attributed
+        let fullPlainText = headerText + "\n\n" + markdownResult.plainText
+
+        #if os(iOS)
+        let renderer = UIGraphicsPDFRenderer(bounds: CGRect(origin: .zero, size: options.paperSize))
+        let data = renderer.pdfData { context in
+            context.beginPage()
+            drawContent(
+                context: context.cgContext,
+                attributedString: bodyAttributed,
+                header: headerText,
+                options: options,
+                beginNewPage: {
+                    context.beginPage()
+                }
+            )
+        }
+        #else
+        let data = NSMutableData()
+        guard let consumer = CGDataConsumer(data: data) else {
+            throw NSError(domain: "TextPagePDFRenderer", code: 1, userInfo: [NSLocalizedDescriptionKey: "Failed to allocate PDF consumer"])
+        }
+        var mediaBox = CGRect(origin: .zero, size: options.paperSize)
+        guard let cgContext = CGContext(consumer: consumer, mediaBox: &mediaBox, nil) else {
+            throw NSError(domain: "TextPagePDFRenderer", code: 2, userInfo: [NSLocalizedDescriptionKey: "Failed to create PDF context"])
+        }
+
+        cgContext.beginPDFPage(nil)
+        drawContent(
+            context: cgContext,
+            attributedString: bodyAttributed,
+            header: headerText,
+            options: options,
+            beginNewPage: {
+                cgContext.beginPDFPage(nil)
+            }
+        )
+        cgContext.endPDFPage()
+        cgContext.closePDF()
+        #endif
+
+        return TextPageRenderOutput(pdfData: data as Data, plainText: fullPlainText)
+    }
+
+    private func drawContent(
+        context cgContext: CGContext,
+        attributedString: NSAttributedString,
+        header: String,
+        options: TextPageRenderOptions,
+        beginNewPage: () -> Void
+    ) {
+        let headerHeight = lineHeight(for: options.headerFont)
+        let textRect = textBoundingRect(options: options, headerHeight: headerHeight)
+
+        drawHeader(header, in: cgContext, options: options, headerHeight: headerHeight)
+        drawBody(attributedString, header: header, in: cgContext, textRect: textRect, options: options, beginNewPage: beginNewPage)
+    }
+
+    private func drawHeader(_ header: String, in context: CGContext, options: TextPageRenderOptions, headerHeight: CGFloat) {
+        let headerRect = CGRect(
+            x: options.insets.left,
+            y: options.paperSize.height - options.insets.top - headerHeight,
+            width: options.paperSize.width - options.insets.left - options.insets.right,
+            height: headerHeight
+        )
+
+        #if os(iOS)
+        let attributes: [NSAttributedString.Key: Any] = [
+            .font: options.headerFont,
+            .foregroundColor: options.headerColor
+        ]
+        (header as NSString).draw(in: headerRect, withAttributes: attributes)
+        #else
+        let attributes: [NSAttributedString.Key: Any] = [
+            .font: options.headerFont,
+            .foregroundColor: options.headerColor
+        ]
+        (header as NSString).draw(in: headerRect, withAttributes: attributes)
+        #endif
+    }
+
+    private func drawBody(
+        _ attributedString: NSAttributedString,
+        header: String,
+        in context: CGContext,
+        textRect: CGRect,
+        options: TextPageRenderOptions,
+        beginNewPage: () -> Void
+    ) {
+        let framesetter = CTFramesetterCreateWithAttributedString(attributedString)
+        var currentRange = CFRange(location: 0, length: 0)
+
+        while currentRange.location < attributedString.length {
+            let path = CGMutablePath()
+            path.addRect(textRect)
+
+            let frame = CTFramesetterCreateFrame(framesetter, currentRange, path, nil)
+            let visibleRange = CTFrameGetVisibleStringRange(frame)
+
+            context.saveGState()
+            context.textMatrix = .identity
+            context.translateBy(x: 0, y: options.paperSize.height)
+            context.scaleBy(x: 1, y: -1)
+            CTFrameDraw(frame, context)
+            context.restoreGState()
+#if DEBUG
+            print("DEBUG TextPagePDFRenderer: drew range length = \(visibleRange.length)")
+#endif
+
+            currentRange.location += visibleRange.length
+            if visibleRange.length == 0 {
+                break
+            }
+
+            if currentRange.location < attributedString.length {
+                beginNewPage()
+                drawHeader(header, in: context, options: options, headerHeight: lineHeight(for: options.headerFont))
+            }
+        }
+    }
+
+    private func textBoundingRect(options: TextPageRenderOptions, headerHeight: CGFloat) -> CGRect {
+        CGRect(
+            x: options.insets.left,
+            y: options.insets.bottom,
+            width: options.paperSize.width - options.insets.left - options.insets.right,
+            height: options.paperSize.height - options.insets.bottom - options.insets.top - headerHeight - options.headerSpacing
+        )
+    }
+
+    private func makeBodyAttributedString(from markdown: String, options: TextPageRenderOptions) -> TextPageMarkdownFormatter.Result {
+        if markdown.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
+            return TextPageMarkdownFormatter.Result(attributed: NSAttributedString(string: ""), plainText: "")
+        }
+
+        let typography = TextPageTypography.current()
+        let headingFonts = typography.headingFonts
+
+        let styles = TextPageMarkdownFormatter.Styles(
+            bodyFont: options.bodyFont,
+            headingFonts: headingFonts,
+            boldFont: options.boldFont,
+            italicFont: options.italicFont,
+            monoFont: options.monoFont,
+            bodyColor: options.bodyColor,
+            secondaryColor: options.secondaryColor,
+            accentColor: options.accentColor,
+            lineSpacing: options.lineSpacing,
+            paragraphSpacing: options.paragraphSpacing,
+            headingSpacing: options.headerSpacing,
+            listIndent: 24,
+            blockquoteIndent: 24
+        )
+
+        return TextPageMarkdownFormatter.makePDFBody(from: markdown, styles: styles)
+    }
+
+    private func headingFont(for level: Int, base: PlatformFont) -> PlatformFont {
+        let clamped = max(1, min(level, 3))
+        let sizeMultiplier: CGFloat
+        switch clamped {
+        case 1: sizeMultiplier = 1.4
+        case 2: sizeMultiplier = 1.2
+        default: sizeMultiplier = 1.1
+        }
+        let targetSize = base.pointSize * sizeMultiplier
+        #if os(iOS)
+        return UIFont(descriptor: base.fontDescriptor.withSymbolicTraits(.traitBold) ?? base.fontDescriptor, size: targetSize)
+        #else
+        return NSFontManager.shared.convert(base, toHaveTrait: .boldFontMask)
+        #endif
+    }
+
+    private func lineHeight(for font: PlatformFont) -> CGFloat {
+        #if os(iOS)
+        return font.lineHeight
+        #else
+        return font.ascender - font.descender + font.leading
+        #endif
+    }
+}
diff --git a/Yiana/Yiana/Services/TextPageRenderService.swift b/Yiana/Yiana/Services/TextPageRenderService.swift
new file mode 100644
index 0000000..82d1ac3
--- /dev/null
+++ b/Yiana/Yiana/Services/TextPageRenderService.swift
@@ -0,0 +1,90 @@
+//
+//  TextPageRenderService.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Convenience wrapper that bridges layout preferences with the PDF renderer
+//  and produces data ready to append to an existing document.
+//
+
+import Foundation
+import PDFKit
+#if os(iOS)
+import UIKit
+#endif
+
+final class TextPageRenderService {
+    static let shared = TextPageRenderService()
+
+    private let renderer = TextPagePDFRenderer()
+    private let layoutSettings = TextPageLayoutSettings.shared
+    private let headerFormatter: DateFormatter
+
+    init() {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        formatter.timeStyle = .none
+        headerFormatter = formatter
+    }
+
+    func render(markdown: String, on date: Date = Date()) async throws -> TextPageRenderOutput {
+        let paperSize = await layoutSettings.preferredPaperSize()
+        let options = TextPageRenderOptions.default(for: paperSize)
+        let headerText = "Inserted note â€” \(headerFormatter.string(from: date))"
+        return try renderer.render(markdown: markdown, headerText: headerText, options: options)
+    }
+
+    func renderAndAppend(
+        markdown: String,
+        existingPDFData: Data?,
+        on date: Date = Date()
+    ) async throws -> (combinedPDF: Data, plainText: String, addedPages: Int, renderedPagePDF: Data) {
+        let renderOutput = try await render(markdown: markdown, on: date)
+
+        let baseDocument: PDFDocument
+        if let data = existingPDFData, let existing = PDFDocument(data: data) {
+            baseDocument = existing
+        } else {
+            baseDocument = PDFDocument()
+        }
+
+        let appendedDocument = PDFDocument(data: renderOutput.pdfData) ?? PDFDocument()
+        let appendedPageCount = appendedDocument.pageCount
+        guard appendedPageCount > 0 else {
+            throw NSError(domain: "TextPageRenderService", code: 3, userInfo: [NSLocalizedDescriptionKey: "Rendered PDF contained no pages"])
+        }
+
+#if DEBUG
+        if let previewString = appendedDocument.page(at: 0)?.string {
+            print("DEBUG TextPageRenderService: Rendered text page content length = \(previewString.count)")
+            print("DEBUG TextPageRenderService: Rendered text page content: \n\(previewString)")
+        } else {
+            print("DEBUG TextPageRenderService: Rendered text page has no extractable string")
+        }
+        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent("yiana-rendered-text-page.pdf")
+        do {
+            try renderOutput.pdfData.write(to: tempURL)
+            print("DEBUG TextPageRenderService: Wrote rendered page to \(tempURL.path)")
+        } catch {
+            print("DEBUG TextPageRenderService: Failed to write temp PDF: \(error)")
+        }
+#endif
+
+        for index in 0..<appendedPageCount {
+            guard let page = appendedDocument.page(at: index) else { continue }
+
+            if let copiedPage = page.copy() as? PDFPage {
+                baseDocument.insert(copiedPage, at: baseDocument.pageCount)
+            } else {
+                baseDocument.insert(page, at: baseDocument.pageCount)
+            }
+        }
+
+        guard let combinedData = baseDocument.dataRepresentation() else {
+            throw NSError(domain: "TextPageRenderService", code: 4, userInfo: [NSLocalizedDescriptionKey: "Failed to serialize combined PDF"])
+        }
+
+        return (combinedData, renderOutput.plainText, appendedPageCount, renderOutput.pdfData)
+    }
+}
diff --git a/Yiana/Yiana/Utilities/DebugRenderedPageStore.swift b/Yiana/Yiana/Utilities/DebugRenderedPageStore.swift
new file mode 100644
index 0000000..5a094a7
--- /dev/null
+++ b/Yiana/Yiana/Utilities/DebugRenderedPageStore.swift
@@ -0,0 +1,27 @@
+//
+//  DebugRenderedPageStore.swift
+//  Yiana
+//
+//  Writes the most recently rendered text page to disk when running in DEBUG
+//  so it can be inspected via Files.app.
+//
+
+import Foundation
+
+#if DEBUG
+struct DebugRenderedPageStore {
+    static let shared = DebugRenderedPageStore()
+    private init() {}
+
+    func store(data: Data, near documentURL: URL) {
+        let debugURL = documentURL.deletingLastPathComponent()
+            .appendingPathComponent("_Debug-Rendered-Text-Page.pdf")
+        do {
+            try data.write(to: debugURL, options: .atomic)
+            print("DEBUG DebugRenderedPageStore: wrote rendered text page to \(debugURL.path)")
+        } catch {
+            print("DEBUG DebugRenderedPageStore: failed to write rendered text page: \(error)")
+        }
+    }
+}
+#endif
diff --git a/Yiana/Yiana/Utilities/MarkdownSyntaxHighlighter.swift b/Yiana/Yiana/Utilities/MarkdownSyntaxHighlighter.swift
new file mode 100644
index 0000000..f5dff78
--- /dev/null
+++ b/Yiana/Yiana/Utilities/MarkdownSyntaxHighlighter.swift
@@ -0,0 +1,191 @@
+//
+//  MarkdownSyntaxHighlighter.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Applies lightweight syntax highlighting to Markdown used by the text page
+//  editor. Only covers the subset of Markdown supported by the editor toolbar,
+//  keeping the implementation predictable and cheap enough to run on every
+//  keystroke.
+//
+
+import Foundation
+
+#if os(iOS)
+import UIKit
+typealias MarkdownFont = UIFont
+typealias MarkdownColor = UIColor
+#elseif os(macOS)
+import AppKit
+typealias MarkdownFont = NSFont
+typealias MarkdownColor = NSColor
+#endif
+
+struct MarkdownSyntaxHighlighter {
+    struct Theme {
+        var bodyFont: MarkdownFont
+        var headingFonts: [Int: MarkdownFont]
+        var boldFont: MarkdownFont
+        var italicFont: MarkdownFont
+        var monoFont: MarkdownFont
+        var textColor: MarkdownColor
+        var secondaryTextColor: MarkdownColor
+        var accentColor: MarkdownColor
+
+        static func defaultTheme() -> Theme {
+            let typography = TextPageTypography.current()
+            let headingFonts = typography.headingFonts
+            return Theme(
+                bodyFont: typography.bodyFont,
+                headingFonts: headingFonts,
+                boldFont: typography.boldFont,
+                italicFont: typography.italicFont,
+                monoFont: typography.monoFont,
+                textColor: typography.bodyColor,
+                secondaryTextColor: typography.secondaryColor,
+                accentColor: typography.accentColor
+            )
+        }
+    }
+
+    private let theme: Theme
+
+    init(theme: Theme = .defaultTheme()) {
+        self.theme = theme
+    }
+
+    func applyHighlighting(to attributedString: NSMutableAttributedString) {
+        let fullRange = NSRange(location: 0, length: attributedString.length)
+        guard fullRange.length > 0 else { return }
+
+        attributedString.setAttributes(baseAttributes(), range: fullRange)
+
+        applyHeadingStyle(in: attributedString)
+        applyItalicStyle(in: attributedString)
+        applyBoldStyle(in: attributedString)
+        applyBlockquoteStyle(in: attributedString)
+        applyListStyle(in: attributedString)
+        applyHorizontalRuleStyle(in: attributedString)
+    }
+
+    private func baseAttributes() -> [NSAttributedString.Key: Any] {
+        [.font: theme.bodyFont, .foregroundColor: theme.textColor]
+    }
+
+    func baseTextAttributes() -> [NSAttributedString.Key: Any] {
+        baseAttributes()
+    }
+
+    private func applyHeadingStyle(in attributedString: NSMutableAttributedString) {
+        let pattern = "^(#{1,3})\\s+(.+)$"
+        applyRegex(pattern, options: [.anchorsMatchLines], in: attributedString) { match, mutable in
+            let markerRange = match.range(at: 1)
+            let level: Int
+            if let swiftRange = Range(markerRange, in: mutable.string) {
+                level = mutable.string[swiftRange].count
+            } else {
+                level = 1
+            }
+
+            let baseFont = theme.headingFonts[level] ?? theme.bodyFont
+            let headingFont: MarkdownFont
+            switch level {
+            case 1, 2:
+                headingFont = applyTraits(boldTrait, to: baseFont)
+            case 3:
+                headingFont = applyTraits(italicTrait, to: baseFont)
+            default:
+                headingFont = baseFont
+            }
+
+            mutable.addAttribute(.font, value: headingFont, range: match.range(at: 0))
+            mutable.addAttribute(.foregroundColor, value: theme.textColor, range: match.range(at: 0))
+        }
+    }
+
+    private func applyBoldStyle(in attributedString: NSMutableAttributedString) {
+        let pattern = "(\\*\\*|__)(.+?)(?:\\1)"
+        applyRegex(pattern, options: [], in: attributedString) { match, mutable in
+            let innerRange = match.range(at: 2)
+            mutable.addAttribute(.font, value: theme.boldFont, range: innerRange)
+        }
+    }
+
+    private func applyItalicStyle(in attributedString: NSMutableAttributedString) {
+        let pattern = "(?<![\\*_])(\\*|_)(?!\\1)(?!\\s)(.+?)(?<!\\s)\\1(?!\\1)"
+        applyRegex(pattern, options: [], in: attributedString) { match, mutable in
+            let innerRange = match.range(at: 2)
+            mutable.addAttribute(.font, value: theme.italicFont, range: innerRange)
+        }
+    }
+
+    private func applyBlockquoteStyle(in attributedString: NSMutableAttributedString) {
+        let pattern = "^>\\s+(.+)$"
+        applyRegex(pattern, options: [.anchorsMatchLines], in: attributedString) { match, mutable in
+            mutable.addAttribute(.foregroundColor, value: theme.secondaryTextColor, range: match.range(at: 0))
+        }
+    }
+
+    private func applyListStyle(in attributedString: NSMutableAttributedString) {
+        let unorderedPattern = "^\\s*[-\\*+]\\s+(.+)$"
+        applyRegex(unorderedPattern, options: [.anchorsMatchLines], in: attributedString) { match, mutable in
+            mutable.addAttribute(.foregroundColor, value: theme.textColor, range: match.range(at: 0))
+        }
+
+        let orderedPattern = "^\\s*\\d+\\.\\s+(.+)$"
+        applyRegex(orderedPattern, options: [.anchorsMatchLines], in: attributedString) { match, mutable in
+            mutable.addAttribute(.foregroundColor, value: theme.textColor, range: match.range(at: 0))
+        }
+    }
+
+private func applyHorizontalRuleStyle(in attributedString: NSMutableAttributedString) {
+        let pattern = "^\\s*---\\s*$"
+        applyRegex(pattern, options: [.anchorsMatchLines], in: attributedString) { match, mutable in
+            mutable.addAttribute(.foregroundColor, value: theme.secondaryTextColor, range: match.range(at: 0))
+            mutable.addAttribute(.font, value: theme.monoFont, range: match.range(at: 0))
+        }
+    }
+
+#if os(iOS)
+    private typealias FontTraits = UIFontDescriptor.SymbolicTraits
+    private let boldTrait: FontTraits = .traitBold
+    private let italicTrait: FontTraits = .traitItalic
+#else
+    private typealias FontTraits = NSFontDescriptor.SymbolicTraits
+    private let boldTrait: FontTraits = .bold
+    private let italicTrait: FontTraits = .italic
+#endif
+
+    private func applyTraits(_ traits: FontTraits, to font: MarkdownFont) -> MarkdownFont {
+#if os(iOS)
+        let combined = font.fontDescriptor.symbolicTraits.union(traits)
+        if let descriptor = font.fontDescriptor.withSymbolicTraits(combined) {
+            return MarkdownFont(descriptor: descriptor, size: font.pointSize)
+        }
+        return font
+#else
+        var combined = font.fontDescriptor.symbolicTraits
+        combined.formUnion(traits)
+        if let descriptor = font.fontDescriptor.withSymbolicTraits(combined),
+           let newFont = MarkdownFont(descriptor: descriptor, size: font.pointSize) {
+            return newFont
+        }
+        return font
+#endif
+    }
+
+    private func applyRegex(
+        _ pattern: String,
+        options: NSRegularExpression.Options,
+        in attributedString: NSMutableAttributedString,
+        handler: (NSTextCheckingResult, NSMutableAttributedString) -> Void
+    ) {
+        guard let regex = try? NSRegularExpression(pattern: pattern, options: options) else { return }
+        let range = NSRange(location: 0, length: attributedString.length)
+        regex.enumerateMatches(in: attributedString.string, options: [], range: range) { match, _, _ in
+            guard let match else { return }
+            handler(match, attributedString)
+        }
+    }
+}
diff --git a/Yiana/Yiana/Utilities/TestDataHelper.swift b/Yiana/Yiana/Utilities/TestDataHelper.swift
index 89fff3f..41dbbf0 100644
--- a/Yiana/Yiana/Utilities/TestDataHelper.swift
+++ b/Yiana/Yiana/Utilities/TestDataHelper.swift
@@ -87,7 +87,8 @@ struct TestDataHelper {
             
             Provider: Dr. Jane Smith, MD
             Date: \(DateFormatter.localizedString(from: Date(), dateStyle: .long, timeStyle: .none))
-            """
+            """,
+            hasPendingTextPage: false
         )
         
         // Encode metadata
@@ -135,7 +136,8 @@ struct TestDataHelper {
             pageCount: 1,
             tags: ["test", "pending"],
             ocrCompleted: false,
-            fullText: nil
+            fullText: nil,
+            hasPendingTextPage: false
         )
         
         // Encode metadata
@@ -157,4 +159,4 @@ struct TestDataHelper {
         NotificationCenter.default.post(name: .yianaDocumentsChanged, object: nil)
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/Yiana/Yiana/Utilities/TextPageBrand.swift b/Yiana/Yiana/Utilities/TextPageBrand.swift
new file mode 100644
index 0000000..e74b51a
--- /dev/null
+++ b/Yiana/Yiana/Utilities/TextPageBrand.swift
@@ -0,0 +1,13 @@
+#if os(iOS)
+import UIKit
+#else
+import AppKit
+#endif
+
+enum TextPageBrand {
+    #if os(iOS)
+    static let accentColor: UIColor = UIColor(named: "AccentColor") ?? UIColor.systemBlue
+    #else
+    static let accentColor: NSColor = NSColor(named: "AccentColor") ?? NSColor.systemBlue
+    #endif
+}
diff --git a/Yiana/Yiana/Utilities/TextPageEditorAction.swift b/Yiana/Yiana/Utilities/TextPageEditorAction.swift
new file mode 100644
index 0000000..0ef12c0
--- /dev/null
+++ b/Yiana/Yiana/Utilities/TextPageEditorAction.swift
@@ -0,0 +1,22 @@
+//
+//  TextPageEditorAction.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Simple enum describing formatting commands that the text page editor can
+//  perform. The UIKit/AppKit bridge picks these up and mutates the underlying
+//  text view accordingly.
+//
+
+import Foundation
+
+enum TextPageEditorAction: Equatable {
+    case bold
+    case italic
+    case unorderedList
+    case orderedList
+    case blockquote
+    case horizontalRule
+    case heading(level: Int)
+}
diff --git a/Yiana/Yiana/Utilities/TextPageMarkdownFormatter.swift b/Yiana/Yiana/Utilities/TextPageMarkdownFormatter.swift
new file mode 100644
index 0000000..8ceeb77
--- /dev/null
+++ b/Yiana/Yiana/Utilities/TextPageMarkdownFormatter.swift
@@ -0,0 +1,462 @@
+//
+//  TextPageMarkdownFormatter.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Minimal Markdown formatter tailored for the text-page workflow. Supports the
+//  subset of Markdown exposed by the editor toolbar (headings, emphasis,
+//  blockquotes, lists, horizontal rules, and inline code). Produces attributed
+//  strings with consistent typography so both the PDF renderer and in-app
+//  preview share the same styling.
+//
+
+import Foundation
+#if os(iOS)
+import UIKit
+#else
+import AppKit
+#endif
+
+#if os(iOS)
+private let boldTrait: UIFontDescriptor.SymbolicTraits = .traitBold
+private let italicTrait: UIFontDescriptor.SymbolicTraits = .traitItalic
+#else
+private let boldTrait: NSFontDescriptor.SymbolicTraits = .bold
+private let italicTrait: NSFontDescriptor.SymbolicTraits = .italic
+#endif
+
+struct TextPageMarkdownFormatter {
+    struct Styles {
+        let bodyFont: PlatformFont
+        let headingFonts: [Int: PlatformFont]
+        let boldFont: PlatformFont
+        let italicFont: PlatformFont
+        let monoFont: PlatformFont
+        let bodyColor: PlatformColor
+        let secondaryColor: PlatformColor
+        let accentColor: PlatformColor
+        let lineSpacing: CGFloat
+        let paragraphSpacing: CGFloat
+        let headingSpacing: CGFloat
+        let listIndent: CGFloat
+        let blockquoteIndent: CGFloat
+    }
+
+    struct Result {
+        let attributed: NSAttributedString
+        let plainText: String
+    }
+
+    static func makePDFBody(from markdown: String, styles: Styles) -> Result {
+        MarkdownAttributedBuilder(styles: styles).build(from: markdown)
+    }
+
+    static func makePreviewAttributedString(from markdown: String) -> AttributedString {
+        let typography = TextPageTypography.current()
+        let styles = Styles(
+            bodyFont: typography.bodyFont,
+            headingFonts: typography.headingFonts,
+            boldFont: typography.boldFont,
+            italicFont: typography.italicFont,
+            monoFont: typography.monoFont,
+            bodyColor: typography.bodyColor,
+            secondaryColor: typography.secondaryColor,
+            accentColor: typography.accentColor,
+            lineSpacing: 4,
+            paragraphSpacing: typography.bodyFont.pointSize * 0.6,
+            headingSpacing: typography.bodyFont.pointSize * 0.8,
+            listIndent: 20,
+            blockquoteIndent: 24
+        )
+        let result = MarkdownAttributedBuilder(styles: styles).build(from: markdown)
+        return AttributedString(result.attributed)
+    }
+}
+
+private final class MarkdownAttributedBuilder {
+    private let styles: TextPageMarkdownFormatter.Styles
+
+    init(styles: TextPageMarkdownFormatter.Styles) {
+        self.styles = styles
+    }
+
+    func build(from markdown: String) -> TextPageMarkdownFormatter.Result {
+        let trimmed = markdown.trimmingCharacters(in: .whitespacesAndNewlines)
+        guard !trimmed.isEmpty else {
+            return TextPageMarkdownFormatter.Result(attributed: NSAttributedString(string: ""), plainText: "")
+        }
+
+        let lines = markdown.split(separator: "\n", omittingEmptySubsequences: false)
+        let output = NSMutableAttributedString()
+        var plainLines: [String] = []
+        var isFirstBlock = true
+
+        for rawLine in lines {
+            let line = String(rawLine)
+            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
+
+            if trimmedLine.isEmpty {
+                plainLines.append("")
+                if !isFirstBlock {
+                    output.append(NSAttributedString(string: "\n"))
+                }
+                isFirstBlock = false
+                continue
+            }
+
+            let block = classifyBlock(from: trimmedLine)
+            let blockResult = render(block: block)
+
+            if !isFirstBlock {
+                output.append(NSAttributedString(string: "\n"))
+            }
+            output.append(blockResult.attributed)
+            plainLines.append(blockResult.plainText)
+            isFirstBlock = false
+        }
+
+        let plainText = plainLines.joined(separator: "\n").trimmingCharacters(in: .whitespacesAndNewlines)
+        return TextPageMarkdownFormatter.Result(attributed: output, plainText: plainText)
+    }
+
+    private func classifyBlock(from line: String) -> Block {
+        if let horizontal = horizontalRuleBlock(for: line) {
+            return horizontal
+        }
+        if let heading = headingBlock(for: line) {
+            return heading
+        }
+        if let unordered = unorderedListBlock(for: line) {
+            return unordered
+        }
+        if let ordered = orderedListBlock(for: line) {
+            return ordered
+        }
+        if let quote = blockquoteBlock(for: line) {
+            return quote
+        }
+        return Block(kind: .paragraph, content: line, ordinal: nil)
+    }
+
+    private func render(block: Block) -> (attributed: NSAttributedString, plainText: String) {
+        switch block.kind {
+        case .horizontalRule:
+            let rule = String(repeating: "\u{2500}", count: 24)
+            let style = paragraphStyle(for: .horizontalRule)
+            let attributes: [NSAttributedString.Key: Any] = [
+                .font: styles.monoFont,
+                .foregroundColor: styles.secondaryColor,
+                .paragraphStyle: style
+            ]
+            return (NSAttributedString(string: rule, attributes: attributes), "")
+        case .heading:
+            let font = font(for: block.kind)
+            let baseAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraphStyle(for: block.kind)
+            ]
+            let (content, plain) = inlineAttributedString(for: block.content, baseAttributes: baseAttributes, baseFont: font)
+            return (content, plain)
+        case .blockquote:
+            let font = font(for: block.kind)
+            let baseAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.secondaryColor,
+                .paragraphStyle: paragraphStyle(for: block.kind)
+            ]
+            let (content, plain) = inlineAttributedString(for: block.content, baseAttributes: baseAttributes, baseFont: font)
+            return (content, plain)
+        case .unorderedList:
+            let font = styles.bodyFont
+            let paragraph = paragraphStyle(for: block.kind)
+            let prefixAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraph
+            ]
+            let bullet = NSAttributedString(string: "â€¢\t", attributes: prefixAttributes)
+            let baseAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraph
+            ]
+            let (content, plainContent) = inlineAttributedString(for: block.content, baseAttributes: baseAttributes, baseFont: font)
+            let composed = NSMutableAttributedString()
+            composed.append(bullet)
+            composed.append(content)
+            return (composed, "â€¢ " + plainContent)
+        case .orderedList:
+            let font = styles.bodyFont
+            let paragraph = paragraphStyle(for: block.kind)
+            let marker = "\(block.ordinal ?? 1). "
+            let prefixAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraph
+            ]
+            let markerAttr = NSAttributedString(string: marker, attributes: prefixAttributes)
+            let baseAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraph
+            ]
+            let (content, plainContent) = inlineAttributedString(for: block.content, baseAttributes: baseAttributes, baseFont: font)
+            let composed = NSMutableAttributedString()
+            composed.append(markerAttr)
+            composed.append(content)
+            return (composed, marker + plainContent)
+        case .paragraph:
+            let font = styles.bodyFont
+            let baseAttributes: [NSAttributedString.Key: Any] = [
+                .font: font,
+                .foregroundColor: styles.bodyColor,
+                .paragraphStyle: paragraphStyle(for: block.kind)
+            ]
+            return inlineAttributedString(for: block.content, baseAttributes: baseAttributes, baseFont: font)
+        }
+    }
+
+    private func inlineAttributedString(for text: String,
+                                        baseAttributes: [NSAttributedString.Key: Any],
+                                        baseFont: PlatformFont) -> (NSAttributedString, String) {
+        let segments = parseSegments(in: text)
+        return render(segments: segments, baseAttributes: baseAttributes, baseFont: baseFont)
+    }
+
+    private func render(segments: [InlineSegment],
+                        baseAttributes: [NSAttributedString.Key: Any],
+                        baseFont: PlatformFont) -> (NSAttributedString, String) {
+        let output = NSMutableAttributedString()
+        var plain = ""
+
+        for segment in segments {
+            switch segment {
+            case .text(let value):
+                plain += value
+                output.append(NSAttributedString(string: value, attributes: baseAttributes))
+            case .bold(let inner):
+                var attributes = baseAttributes
+                let derivedFont = boldFont(from: baseFont)
+                attributes[.font] = derivedFont
+                let (child, childPlain) = render(segments: inner, baseAttributes: attributes, baseFont: derivedFont)
+                output.append(child)
+                plain += childPlain
+            case .italic(let inner):
+                var attributes = baseAttributes
+                let derivedFont = italicFont(from: baseFont)
+                attributes[.font] = derivedFont
+                let (child, childPlain) = render(segments: inner, baseAttributes: attributes, baseFont: derivedFont)
+                output.append(child)
+                plain += childPlain
+            case .code(let value):
+                plain += value
+                var attributes = baseAttributes
+                attributes[.font] = styles.monoFont
+                attributes[.foregroundColor] = styles.secondaryColor
+                output.append(NSAttributedString(string: value, attributes: attributes))
+            }
+        }
+
+        return (output, plain)
+    }
+
+    private func parseSegments(in text: String) -> [InlineSegment] {
+        var segments: [InlineSegment] = []
+        var buffer = ""
+        var index = text.startIndex
+
+        func flushBuffer() {
+            if !buffer.isEmpty {
+                segments.append(.text(buffer))
+                buffer.removeAll(keepingCapacity: true)
+            }
+        }
+
+        while index < text.endIndex {
+            if text[index...].hasPrefix("**") || text[index...].hasPrefix("__") {
+                let marker = text[index...].hasPrefix("**") ? "**" : "__"
+                if let end = findClosingMarker(marker, in: text, from: index) {
+                    flushBuffer()
+                    let contentStart = text.index(index, offsetBy: marker.count)
+                    let innerText = String(text[contentStart..<end])
+                    segments.append(.bold(parseSegments(in: innerText)))
+                    index = text.index(end, offsetBy: marker.count)
+                    continue
+                }
+            }
+
+            if text[index] == "*" || text[index] == "_" {
+                let marker = String(text[index])
+                let next = text.index(after: index)
+                if next < text.endIndex, text[next] == text[index] {
+                    // handled by bold branch
+                } else if let end = findClosingMarker(marker, in: text, from: index) {
+                    flushBuffer()
+                    let contentStart = text.index(after: index)
+                    let innerText = String(text[contentStart..<end])
+                    segments.append(.italic(parseSegments(in: innerText)))
+                    index = text.index(after: end)
+                    continue
+                }
+            }
+
+            if text[index] == "`",
+               let end = findClosingMarker("`", in: text, from: index) {
+                flushBuffer()
+                let contentStart = text.index(after: index)
+                let code = String(text[contentStart..<end])
+                segments.append(.code(code))
+                index = text.index(after: end)
+                continue
+            }
+
+            buffer.append(text[index])
+            index = text.index(after: index)
+        }
+
+        flushBuffer()
+        return segments
+    }
+
+    private func findClosingMarker(_ marker: String, in text: String, from start: String.Index) -> String.Index? {
+        var search = text.index(start, offsetBy: marker.count)
+        while search < text.endIndex {
+            if text[search...].hasPrefix(marker) {
+                return search
+            }
+            search = text.index(after: search)
+        }
+        return nil
+    }
+
+    private func headingBlock(for line: String) -> Block? {
+        let hashes = line.prefix { $0 == "#" }
+        guard !hashes.isEmpty, hashes.count <= 3 else { return nil }
+        let level = hashes.count
+        let text = line.dropFirst(level).trimmingCharacters(in: .whitespaces)
+        return Block(kind: .heading(level), content: String(text), ordinal: nil)
+    }
+
+    private func unorderedListBlock(for line: String) -> Block? {
+        let markers = ["- ", "* ", "+ "]
+        for marker in markers where line.hasPrefix(marker) {
+            let content = line.dropFirst(marker.count).trimmingCharacters(in: .whitespaces)
+            return Block(kind: .unorderedList, content: String(content), ordinal: nil)
+        }
+        return nil
+    }
+
+    private func orderedListBlock(for line: String) -> Block? {
+        guard let dotIndex = line.firstIndex(of: ".") else { return nil }
+        let numberPart = line[..<dotIndex]
+        guard let ordinal = Int(numberPart) else { return nil }
+        let remainder = line[line.index(after: dotIndex)...].trimmingCharacters(in: .whitespaces)
+        return Block(kind: .orderedList, content: String(remainder), ordinal: ordinal)
+    }
+
+    private func blockquoteBlock(for line: String) -> Block? {
+        guard line.hasPrefix(">") else { return nil }
+        let content = line.dropFirst().trimmingCharacters(in: .whitespaces)
+        return Block(kind: .blockquote, content: String(content), ordinal: nil)
+    }
+
+    private func horizontalRuleBlock(for line: String) -> Block? {
+        let stripped = line.replacingOccurrences(of: " ", with: "")
+        if stripped == "---" || stripped == "***" || stripped == "___" {
+            return Block(kind: .horizontalRule, content: "", ordinal: nil)
+        }
+        return nil
+    }
+
+    private func paragraphStyle(for kind: Block.Kind) -> NSMutableParagraphStyle {
+        let style = NSMutableParagraphStyle()
+        style.lineSpacing = styles.lineSpacing
+        style.paragraphSpacing = styles.paragraphSpacing
+        style.alignment = .left
+
+        switch kind {
+        case .heading:
+            style.paragraphSpacing = styles.headingSpacing
+        case .unorderedList, .orderedList:
+            style.headIndent = styles.listIndent
+            style.firstLineHeadIndent = styles.listIndent
+            style.tabStops = [NSTextTab(textAlignment: .left, location: styles.listIndent)]
+        case .blockquote:
+            style.headIndent = styles.blockquoteIndent
+            style.firstLineHeadIndent = styles.blockquoteIndent
+        case .horizontalRule:
+            style.alignment = .center
+        case .paragraph:
+            break
+        }
+
+        return style
+    }
+
+    private func font(for kind: Block.Kind) -> PlatformFont {
+        switch kind {
+        case .heading(let level):
+            if let font = styles.headingFonts[level] {
+                if level == 3 {
+                    return italicFont(from: font)
+                }
+                return boldFont(from: font)
+            }
+            return styles.headingFonts[3] ?? styles.bodyFont
+        case .blockquote:
+            return italicFont(from: styles.bodyFont)
+        default:
+            return styles.bodyFont
+        }
+    }
+
+    private func boldFont(from base: PlatformFont) -> PlatformFont {
+        let candidate = base.applyingTraits(boldTrait)
+        if fontsEqual(candidate, base) {
+            return styles.boldFont
+        }
+        return candidate
+    }
+
+    private func italicFont(from base: PlatformFont) -> PlatformFont {
+        let candidate = base.applyingTraits(italicTrait)
+        if fontsEqual(candidate, base) {
+            return styles.italicFont
+        }
+        return candidate
+    }
+
+#if os(iOS)
+    private func fontsEqual(_ lhs: UIFont, _ rhs: UIFont) -> Bool {
+        lhs.fontDescriptor == rhs.fontDescriptor && lhs.pointSize == rhs.pointSize
+    }
+#else
+    private func fontsEqual(_ lhs: NSFont, _ rhs: NSFont) -> Bool {
+        lhs.fontDescriptor == rhs.fontDescriptor && abs(lhs.pointSize - rhs.pointSize) < .ulpOfOne
+    }
+#endif
+
+    private struct Block {
+        enum Kind {
+            case heading(Int)
+            case unorderedList
+            case orderedList
+            case blockquote
+            case horizontalRule
+            case paragraph
+        }
+
+        let kind: Kind
+        let content: String
+        let ordinal: Int?
+    }
+
+    private enum InlineSegment {
+        case text(String)
+        case bold([InlineSegment])
+        case italic([InlineSegment])
+        case code(String)
+    }
+}
diff --git a/Yiana/Yiana/Utilities/TextPagePlatformTypes.swift b/Yiana/Yiana/Utilities/TextPagePlatformTypes.swift
new file mode 100644
index 0000000..39a157e
--- /dev/null
+++ b/Yiana/Yiana/Utilities/TextPagePlatformTypes.swift
@@ -0,0 +1,9 @@
+#if os(iOS)
+import UIKit
+public typealias PlatformFont = UIFont
+public typealias PlatformColor = UIColor
+#else
+import AppKit
+public typealias PlatformFont = NSFont
+public typealias PlatformColor = NSColor
+#endif
diff --git a/Yiana/Yiana/Utilities/TextPageTypography.swift b/Yiana/Yiana/Utilities/TextPageTypography.swift
new file mode 100644
index 0000000..d0353ab
--- /dev/null
+++ b/Yiana/Yiana/Utilities/TextPageTypography.swift
@@ -0,0 +1,100 @@
+#if os(iOS)
+import UIKit
+#else
+import AppKit
+#endif
+
+struct TextPageTypography {
+    let bodyFont: PlatformFont
+    let headingFonts: [Int: PlatformFont]
+    let boldFont: PlatformFont
+    let italicFont: PlatformFont
+    let monoFont: PlatformFont
+    let bodyColor: PlatformColor
+    let secondaryColor: PlatformColor
+    let accentColor: PlatformColor
+
+    static func current() -> TextPageTypography {
+        #if os(iOS)
+        let body = UIFont.preferredFont(forTextStyle: .body)
+        let headingFonts: [Int: UIFont] = [
+            1: UIFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.6),
+            2: UIFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.35),
+            3: UIFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.1)
+        ]
+        let bold = UIFont(
+            descriptor: body.fontDescriptor.withSymbolicTraits(.traitBold) ?? body.fontDescriptor,
+            size: body.pointSize
+        )
+        let italic = UIFont(
+            descriptor: body.fontDescriptor.withSymbolicTraits(.traitItalic) ?? body.fontDescriptor,
+            size: body.pointSize
+        )
+        let mono = UIFont.monospacedSystemFont(ofSize: body.pointSize, weight: .regular)
+        let bodyColor = UIColor.label
+        let secondary = UIColor.secondaryLabel
+        let accent = TextPageBrand.accentColor
+        return TextPageTypography(
+            bodyFont: body,
+            headingFonts: headingFonts,
+            boldFont: bold,
+            italicFont: italic,
+            monoFont: mono,
+            bodyColor: bodyColor,
+            secondaryColor: secondary,
+            accentColor: accent
+        )
+        #else
+        let body = NSFont.preferredFont(forTextStyle: .body)
+        let headingFonts: [Int: NSFont] = [
+            1: NSFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.6) ?? body,
+            2: NSFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.35) ?? body,
+            3: NSFont(descriptor: body.fontDescriptor, size: body.pointSize * 1.1) ?? body
+        ]
+        let boldDescriptor = body.fontDescriptor.withSymbolicTraits(.bold)
+        let italicDescriptor = body.fontDescriptor.withSymbolicTraits(.italic)
+        let bold = NSFont(descriptor: boldDescriptor, size: body.pointSize) ?? body
+        let italic = NSFont(descriptor: italicDescriptor, size: body.pointSize) ?? body
+        let mono = NSFont.monospacedSystemFont(ofSize: body.pointSize, weight: .regular)
+        let bodyColor = NSColor.textColor
+        let secondary = NSColor.secondaryLabelColor
+        let accent = TextPageBrand.accentColor
+        return TextPageTypography(
+            bodyFont: body,
+            headingFonts: headingFonts,
+            boldFont: bold,
+            italicFont: italic,
+            monoFont: mono,
+            bodyColor: bodyColor,
+            secondaryColor: secondary,
+            accentColor: accent
+        )
+        #endif
+    }
+}
+
+#if os(iOS)
+typealias FontDescriptorTraits = UIFontDescriptor.SymbolicTraits
+#else
+typealias FontDescriptorTraits = NSFontDescriptor.SymbolicTraits
+#endif
+
+extension PlatformFont {
+    func applyingTraits(_ traits: FontDescriptorTraits) -> PlatformFont {
+        #if os(iOS)
+        let combined = fontDescriptor.symbolicTraits.union(traits)
+        if let descriptor = fontDescriptor.withSymbolicTraits(combined) {
+            return PlatformFont(descriptor: descriptor, size: pointSize)
+        }
+        return self
+        #else
+        var combined = fontDescriptor.symbolicTraits
+        combined.formUnion(traits)
+        let descriptor = fontDescriptor.withSymbolicTraits(combined)
+        if let font = PlatformFont(descriptor: descriptor, size: pointSize) {
+            return font
+        }
+        return self
+        #endif
+    }
+}
diff --git a/Yiana/Yiana/ViewModels/DocumentListViewModel.swift b/Yiana/Yiana/ViewModels/DocumentListViewModel.swift
index d5d0b6e..2257ec7 100644
--- a/Yiana/Yiana/ViewModels/DocumentListViewModel.swift
+++ b/Yiana/Yiana/ViewModels/DocumentListViewModel.swift
@@ -303,16 +303,44 @@ class DocumentListViewModel: ObservableObject {
             let docsPath = "/" + pathComponents[0...docsIndex].dropFirst().joined(separator: "/")
             return URL(fileURLWithPath: docsPath)
         }
-        return nil
+
+        // Fallback: walk up the hierarchy looking for an `.ocr_results` sibling
+        let fileManager = FileManager.default
+        var current = documentURL.deletingLastPathComponent()
+
+        while current.path != "/" {
+            var isDir: ObjCBool = false
+            let ocrPath = current.appendingPathComponent(".ocr_results").path
+            if fileManager.fileExists(atPath: ocrPath, isDirectory: &isDir), isDir.boolValue {
+                return current
+            }
+
+            let parent = current.deletingLastPathComponent()
+            if parent == current { break }
+            current = parent
+        }
+
+        // As a last resort, return the document's immediate parent directory
+        return documentURL.deletingLastPathComponent()
     }
     
     nonisolated private func searchOCRContentWithPageInfo(at documentURL: URL, for searchText: String) -> (snippet: String, pageNumber: Int)? {
         // Build path to OCR JSON file
         // Get documents directory from the document URL itself
         guard let documentsDir = getDocumentsDirectory(from: documentURL) else { return nil }
-        let relativePath = documentURL.deletingLastPathComponent().path.replacingOccurrences(of: documentsDir.path, with: "")
-        let trimmedPath = relativePath.hasPrefix("/") ? String(relativePath.dropFirst()) : relativePath
-        
+        let docParent = documentURL.deletingLastPathComponent().standardizedFileURL
+        let baseComponents = documentsDir.standardizedFileURL.pathComponents
+        let parentComponents = docParent.pathComponents
+
+        let trimmedComponents: [String]
+        if parentComponents.starts(with: baseComponents) {
+            trimmedComponents = Array(parentComponents.dropFirst(baseComponents.count))
+        } else {
+            trimmedComponents = parentComponents
+        }
+
+        let trimmedPath = trimmedComponents.joined(separator: "/")
+
         let ocrResultsDir = documentsDir
             .appendingPathComponent(".ocr_results")
             .appendingPathComponent(trimmedPath)
@@ -523,6 +551,12 @@ class DocumentListViewModel: ObservableObject {
             return
         }
 
+        // If running under XCTest, bypass debounce so tests can await completion synchronously
+        if ProcessInfo.processInfo.environment["XCTestConfigurationFilePath"] != nil {
+            await performSearch(searchText: searchText)
+            return
+        }
+
         // Debounce search for non-empty queries
         searchDebounceTask = Task {
             do {
diff --git a/Yiana/Yiana/ViewModels/DocumentViewModel.swift b/Yiana/Yiana/ViewModels/DocumentViewModel.swift
index f529d20..07b623a 100644
--- a/Yiana/Yiana/ViewModels/DocumentViewModel.swift
+++ b/Yiana/Yiana/ViewModels/DocumentViewModel.swift
@@ -37,7 +37,7 @@ class DocumentViewModel: ObservableObject {
             }
         }
     }
-    
+
     var autoSaveEnabled = false {
         didSet {
             if autoSaveEnabled && hasChanges {
@@ -45,9 +45,10 @@ class DocumentViewModel: ObservableObject {
             }
         }
     }
-    
+
     private let document: NoteDocument
     private var autoSaveTask: Task<Void, Never>?
+    private let textRenderService = TextPageRenderService.shared
     
     init(document: NoteDocument) {
         self.document = document
@@ -161,12 +162,12 @@ class DocumentViewModel: ObservableObject {
             return ""
         }
     }
-    
+
     private func scheduleAutoSave() {
         autoSaveTask?.cancel()
-        
+
         guard autoSaveEnabled && hasChanges else { return }
-        
+
         autoSaveTask = Task {
             try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
             if !Task.isCancelled {
@@ -174,6 +175,111 @@ class DocumentViewModel: ObservableObject {
             }
         }
     }
+
+    var metadataSnapshot: DocumentMetadata {
+        document.metadata
+    }
+
+    func updatePendingTextPageFlag(_ hasDraft: Bool) {
+        guard document.metadata.hasPendingTextPage != hasDraft else { return }
+        document.metadata.hasPendingTextPage = hasDraft
+        hasChanges = true
+        scheduleAutoSave()
+    }
+
+    /// Renders the provided Markdown into a PDF page, appends it to the current document,
+    /// and updates metadata/search fields accordingly.
+    @discardableResult
+    func appendTextPage(
+        markdown: String,
+        appendPlainTextToMetadata: Bool,
+        cachedRenderedPage: Data? = nil,
+        cachedPlainText: String? = nil
+    ) async throws -> (plainText: String, addedPages: Int) {
+        let existingData = pdfData
+
+        let combinedData: Data
+        let plainText: String
+        let addedPages: Int
+        let renderedPageData: Data
+
+        if let cachedRenderedPage,
+           let appendedDocument = PDFDocument(data: cachedRenderedPage),
+           appendedDocument.pageCount > 0 {
+            let baseDocument: PDFDocument
+            if let existingData, let existing = PDFDocument(data: existingData) {
+                baseDocument = existing
+            } else {
+                baseDocument = PDFDocument()
+            }
+
+            addedPages = appendedDocument.pageCount
+            for index in 0..<addedPages {
+                guard let page = appendedDocument.page(at: index) else { continue }
+                if let copiedPage = page.copy() as? PDFPage {
+                    baseDocument.insert(copiedPage, at: baseDocument.pageCount)
+                } else {
+                    baseDocument.insert(page, at: baseDocument.pageCount)
+                }
+            }
+
+            guard let mergedData = baseDocument.dataRepresentation() else {
+                throw NSError(domain: "TextPageRender", code: 6, userInfo: [NSLocalizedDescriptionKey: "Failed to merge cached rendered page"])
+            }
+
+            combinedData = mergedData
+            plainText = cachedPlainText ?? markdown
+            renderedPageData = cachedRenderedPage
+        } else {
+            let result = try await textRenderService.renderAndAppend(markdown: markdown, existingPDFData: existingData)
+            combinedData = result.combinedPDF
+            plainText = result.plainText
+            addedPages = result.addedPages
+            renderedPageData = result.renderedPagePDF
+        }
+
+        pdfData = combinedData
+
+        if let updatedPDF = PDFDocument(data: combinedData) {
+            document.metadata.pageCount = updatedPDF.pageCount
+        }
+
+        document.metadata.modified = Date()
+        document.metadata.hasPendingTextPage = false
+
+        if appendPlainTextToMetadata {
+            let trimmed = plainText.trimmingCharacters(in: .whitespacesAndNewlines)
+            if !trimmed.isEmpty {
+                if var existing = document.metadata.fullText, !existing.isEmpty {
+                    existing.append("\n\n")
+                    existing.append(trimmed)
+                    document.metadata.fullText = existing
+                } else {
+                    document.metadata.fullText = trimmed
+                }
+            }
+        }
+
+#if DEBUG
+        if let combinedDoc = PDFDocument(data: combinedData) {
+            let lastIndex = combinedDoc.pageCount - 1
+            let pageString = combinedDoc.page(at: lastIndex)?.string ?? "<nil>"
+            print("DEBUG DocumentViewModel: Combined PDF last page string length = \(pageString.count)")
+            print("DEBUG DocumentViewModel: Combined PDF last page string = \n\(pageString)")
+        } else {
+            print("DEBUG DocumentViewModel: Failed to load combined PDF for logging")
+        }
+#endif
+
+        hasChanges = true
+        scheduleAutoSave()
+
+        #if DEBUG
+        DebugRenderedPageStore.shared.store(data: renderedPageData, near: document.fileURL)
+        #endif
+
+        return (plainText: plainText, addedPages: addedPages)
+    }
 }
 
 #else
diff --git a/Yiana/Yiana/ViewModels/TextPageEditorViewModel.swift b/Yiana/Yiana/ViewModels/TextPageEditorViewModel.swift
new file mode 100644
index 0000000..42e693d
--- /dev/null
+++ b/Yiana/Yiana/ViewModels/TextPageEditorViewModel.swift
@@ -0,0 +1,287 @@
+//
+//  TextPageEditorViewModel.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  Coordinates the lifecycle of a single in-progress text page draft. The view
+//  model loads existing drafts, autosaves user input to the sidecar manager,
+//  tracks cursor state, and notifies listeners when the draft state changes.
+//
+
+import Foundation
+
+@MainActor
+final class TextPageEditorViewModel: ObservableObject {
+    enum DraftState: Equatable {
+        case empty
+        case loaded(updatedAt: Date)
+        case modified
+        case saved(updatedAt: Date)
+        case failed(Error)
+
+        static func == (lhs: DraftState, rhs: DraftState) -> Bool {
+            switch (lhs, rhs) {
+            case (.empty, .empty), (.modified, .modified):
+                return true
+            case let (.loaded(a), .loaded(b)):
+                return a == b
+            case let (.saved(a), .saved(b)):
+                return a == b
+            case let (.failed(errorA), .failed(errorB)):
+                return String(describing: errorA) == String(describing: errorB)
+            default:
+                return false
+            }
+        }
+    }
+
+    @Published var content: String {
+        didSet {
+            guard content != oldValue else { return }
+            if isProgrammaticContentChange {
+                isProgrammaticContentChange = false
+                notifyDraftStateChange()
+                return
+            }
+            hasPendingChanges = true
+            scheduleAutosave()
+            notifyDraftStateChange()
+            scheduleLiveRender()
+        }
+    }
+
+    @Published private(set) var state: DraftState
+    @Published private(set) var lastSavedAt: Date?
+    @Published var cursorPosition: Int? {
+        didSet {
+            lastKnownCursorPosition = cursorPosition
+        }
+    }
+    @Published var showPreview: Bool = false
+    @Published var recoveredDraftTimestamp: Date?
+    @Published private(set) var latestRenderedPageData: Data?
+    @Published private(set) var latestRenderedPlainText: String?
+    @Published private(set) var liveRenderError: String?
+
+    let documentURL: URL
+    private(set) var metadata: DocumentMetadata
+
+    var onDraftStateChange: ((Bool) -> Void)?
+
+    private let draftManager: TextPageDraftManager
+    private let autosaveInterval: TimeInterval
+    private let renderService = TextPageRenderService.shared
+
+    private var hasPendingChanges = false
+    private var autosaveTask: Task<Void, Never>?
+    private var hasLoadedInitialDraft = false
+    private var lastSavedContent = ""
+    private var lastKnownCursorPosition: Int?
+    private var isProgrammaticContentChange = false
+    private var liveRenderTask: Task<Void, Never>?
+
+    init(
+        documentURL: URL,
+        metadata: DocumentMetadata,
+        initialContent: String = "",
+        draftManager: TextPageDraftManager = .shared,
+        autosaveInterval: TimeInterval = 30
+    ) {
+        self.documentURL = documentURL
+        self.metadata = metadata
+        self.draftManager = draftManager
+        self.autosaveInterval = autosaveInterval
+        self.content = initialContent
+        self.lastSavedContent = initialContent
+        self.state = initialContent.isEmpty ? .empty : .loaded(updatedAt: Date())
+        self.lastSavedAt = nil
+        self.recoveredDraftTimestamp = nil
+    }
+
+    deinit {
+        autosaveTask?.cancel()
+        liveRenderTask?.cancel()
+    }
+
+    func refreshMetadata(_ metadata: DocumentMetadata) {
+        guard metadata.id == self.metadata.id else { return }
+        self.metadata = metadata
+    }
+
+    func loadDraftIfAvailable() async {
+        guard !hasLoadedInitialDraft else { return }
+        if let draft = await draftManager.loadDraft(for: documentURL, metadata: metadata) {
+            isProgrammaticContentChange = true
+            content = draft.content
+            lastSavedContent = draft.content
+            cursorPosition = draft.metadata.cursorPosition
+            lastKnownCursorPosition = draft.metadata.cursorPosition
+            lastSavedAt = draft.metadata.updatedAt
+            recoveredDraftTimestamp = draft.metadata.updatedAt
+            state = .loaded(updatedAt: draft.metadata.updatedAt)
+            hasPendingChanges = false
+            notifyDraftStateChange()
+        } else {
+            state = content.isEmpty ? .empty : .loaded(updatedAt: Date())
+            notifyDraftStateChange()
+        }
+        hasLoadedInitialDraft = true
+        scheduleLiveRender(immediate: true)
+    }
+
+    func togglePreview(forTraitCollectionIsCompact: Bool) {
+        if forTraitCollectionIsCompact {
+            showPreview.toggle()
+        } else {
+            showPreview = true
+        }
+    }
+
+    func applyFormatting(_ transform: (inout String, inout Int?) -> Void) {
+        var mutableText = content
+        var cursor = cursorPosition
+        transform(&mutableText, &cursor)
+        content = mutableText
+        cursorPosition = cursor
+    }
+
+    func flushDraftNow() async {
+        autosaveTask?.cancel()
+        await performSave()
+    }
+
+    func discardDraft() async {
+        autosaveTask?.cancel()
+        liveRenderTask?.cancel()
+        do {
+            try await draftManager.removeDraft(for: documentURL, metadata: metadata)
+            lastSavedContent = ""
+            isProgrammaticContentChange = true
+            content = ""
+            lastSavedAt = nil
+            state = .empty
+            hasPendingChanges = false
+            notifyDraftStateChange()
+            latestRenderedPageData = nil
+            latestRenderedPlainText = nil
+            liveRenderError = nil
+        } catch {
+            state = .failed(error)
+        }
+    }
+
+    private func scheduleAutosave() {
+        autosaveTask?.cancel()
+        guard hasLoadedInitialDraft else { return }
+        guard hasPendingChanges else { return }
+
+        autosaveTask = Task { [weak self] in
+            guard let self else { return }
+            let delay = UInt64(autosaveInterval * 1_000_000_000)
+            do {
+                try await Task.sleep(nanoseconds: delay)
+            } catch {
+                return
+            }
+            if Task.isCancelled { return }
+            await self.performSave()
+        }
+    }
+
+    private func performSave() async {
+        guard hasPendingChanges else { return }
+        hasPendingChanges = false
+
+        let trimmedContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
+        if trimmedContent.isEmpty {
+            do {
+                try await draftManager.removeDraft(for: documentURL, metadata: metadata)
+                lastSavedContent = ""
+                lastSavedAt = nil
+                state = .empty
+                notifyDraftStateChange()
+                latestRenderedPageData = nil
+                latestRenderedPlainText = nil
+                liveRenderError = nil
+            } catch {
+                state = .failed(error)
+            }
+            return
+        }
+
+        let timestamp = Date()
+        let draft = TextPageDraft(
+            content: content,
+            metadata: TextPageDraftMetadata(updatedAt: timestamp, cursorPosition: lastKnownCursorPosition)
+        )
+
+        do {
+            try await draftManager.saveDraft(draft, for: documentURL, metadata: metadata)
+            lastSavedContent = content
+            lastSavedAt = timestamp
+            state = .saved(updatedAt: timestamp)
+            notifyDraftStateChange()
+        } catch {
+            state = .failed(error)
+            hasPendingChanges = true
+        }
+    }
+
+    private func scheduleLiveRender(immediate: Bool = false) {
+        guard hasLoadedInitialDraft else { return }
+
+        liveRenderTask?.cancel()
+
+        let snapshot = content
+        liveRenderTask = Task { [weak self] in
+            guard let self else { return }
+
+            let trimmed = snapshot.trimmingCharacters(in: .whitespacesAndNewlines)
+            if trimmed.isEmpty {
+                await MainActor.run { [weak self] in
+                    self?.latestRenderedPageData = nil
+                    self?.latestRenderedPlainText = nil
+                    self?.liveRenderError = nil
+                }
+                return
+            }
+
+            if !immediate {
+                do {
+                    try await Task.sleep(nanoseconds: 400_000_000)
+                } catch { return }
+            }
+
+            if Task.isCancelled { return }
+
+            do {
+                let output = try await renderService.render(markdown: snapshot)
+                await MainActor.run { [weak self] in
+                    self?.latestRenderedPageData = output.pdfData
+                    self?.latestRenderedPlainText = output.plainText
+                    self?.liveRenderError = nil
+                }
+            } catch {
+                await MainActor.run { [weak self] in
+                    self?.liveRenderError = error.localizedDescription
+                }
+            }
+        }
+    }
+
+    private func notifyDraftStateChange() {
+        let hasDraft = !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || !lastSavedContent.isEmpty
+        onDraftStateChange?(hasDraft)
+    }
+}
+
+extension TextPageEditorViewModel.DraftState {
+    var updatedAt: Date? {
+        switch self {
+        case .loaded(let date): return date
+        case .saved(let date): return date
+        default: return nil
+        }
+    }
+}
diff --git a/Yiana/Yiana/Views/DocumentEditView.swift b/Yiana/Yiana/Views/DocumentEditView.swift
index d59b75a..4e479b2 100644
--- a/Yiana/Yiana/Views/DocumentEditView.swift
+++ b/Yiana/Yiana/Views/DocumentEditView.swift
@@ -39,6 +39,11 @@ struct DocumentEditView: View {
     @State private var activeSheet: ActiveSheet?
     @State private var showingMarkupError = false
     @State private var markupErrorMessage = ""
+    @State private var textEditorViewModel: TextPageEditorViewModel?
+    @State private var showTextEditor = false
+    @State private var isRenderingTextPage = false
+    @State private var textAppendErrorMessage: String?
+    @State private var showingTextAppendError = false
     
     private let scanningService = ScanningService()
     private let exportService = ExportService()
@@ -99,11 +104,19 @@ struct DocumentEditView: View {
                 }
             }
         }
+        .sheet(isPresented: $showTextEditor) {
+            textEditorSheet
+        }
         .alert("Markup Error", isPresented: $showingMarkupError) {
             Button("OK") { }
         } message: {
             Text(markupErrorMessage)
         }
+        .alert("Text Page Error", isPresented: $showingTextAppendError) {
+            Button("OK") { }
+        } message: {
+            Text(textAppendErrorMessage ?? "Failed to append text page.")
+        }
     }
     
     @ViewBuilder
@@ -146,6 +159,15 @@ struct DocumentEditView: View {
                 }
             }
 
+            if isRenderingTextPage {
+                Color.black.opacity(0.35)
+                    .ignoresSafeArea()
+                ProgressView("Rendering text pageâ€¦")
+                    .padding(24)
+                    .background(Color(.systemBackground))
+                    .cornerRadius(16)
+            }
+
             // Overlay title field at top
             VStack {
                 if showTitleField {
@@ -177,7 +199,7 @@ struct DocumentEditView: View {
                     // Minimal title display with back button
                     HStack(spacing: 0) {
                         Button(action: {
-                            dismiss()
+                            handleDismiss()
                         }) {
                             HStack {
                                 Image(systemName: "chevron.left")
@@ -242,7 +264,7 @@ struct DocumentEditView: View {
     }
     
     private var scanButtonBar: some View {
-        HStack(spacing: 40) {
+        HStack(spacing: 32) {
             // Color scan button - "Scan"
             Button(action: {
                 if scanningService.isScanningAvailable() {
@@ -272,7 +294,7 @@ struct DocumentEditView: View {
                 }
             }
             .disabled(!scanningService.isScanningAvailable())
-            
+
             // B&W document scan button - "Doc"
             Button(action: {
                 if scanningService.isScanningAvailable() {
@@ -285,7 +307,7 @@ struct DocumentEditView: View {
                         Circle()
                             .fill(Color.gray.opacity(0.3))
                             .frame(width: 60, height: 60)
-                        
+
                         Image(systemName: "doc.text.viewfinder")
                             .font(.title2)
                             .foregroundColor(.white)
@@ -296,9 +318,136 @@ struct DocumentEditView: View {
                 }
             }
             .disabled(!scanningService.isScanningAvailable())
+
+            if textEditorViewModel != nil {
+                textPageButton
+            }
         }
         .padding(.bottom, 20)
     }
+
+    private var textPageButton: some View {
+        let hasDraft = (textEditorViewModel?.state ?? .empty) != .empty
+
+        return Button(action: {
+            showTextEditor = true
+        }) {
+            VStack(spacing: 4) {
+                ZStack {
+                    Circle()
+                        .fill(Color("AccentColor").opacity(0.3))
+                        .frame(width: 60, height: 60)
+
+                    Image(systemName: hasDraft ? "doc.badge.plus" : "doc.text")
+                        .font(.title2)
+                        .foregroundColor(.white)
+
+                    if hasDraft {
+                        Circle()
+                            .fill(Color.green)
+                            .frame(width: 12, height: 12)
+                            .offset(x: 22, y: -22)
+                    }
+                }
+                Text(hasDraft ? "Resume" : "Text")
+                    .font(.caption)
+                    .foregroundColor(.primary)
+            }
+        }
+    }
+
+    private func handleDismiss() {
+        if isRenderingTextPage { return }
+        Task {
+            if showTextEditor {
+                await MainActor.run { showTextEditor = false }
+            }
+
+            let canDismiss = await finalizeTextPageIfNeeded()
+            if canDismiss {
+                if let viewModel = viewModel {
+                    _ = await viewModel.save()
+                }
+                await MainActor.run {
+                    dismiss()
+                }
+            }
+        }
+    }
+
+    private func finalizeTextPageIfNeeded() async -> Bool {
+        guard let textEditorViewModel, let viewModel = viewModel else { return true }
+
+        let trimmed = textEditorViewModel.content.trimmingCharacters(in: .whitespacesAndNewlines)
+        if trimmed.isEmpty {
+            await textEditorViewModel.discardDraft()
+            viewModel.updatePendingTextPageFlag(false)
+            return true
+        }
+
+        await MainActor.run { isRenderingTextPage = true }
+
+        do {
+            await textEditorViewModel.flushDraftNow()
+            let markdown = textEditorViewModel.content
+            let cachedRender = textEditorViewModel.latestRenderedPageData
+            let cachedPlain = textEditorViewModel.latestRenderedPlainText ?? trimmed
+            _ = try await viewModel.appendTextPage(
+                markdown: markdown,
+                appendPlainTextToMetadata: true,
+                cachedRenderedPage: cachedRender,
+                cachedPlainText: cachedPlain
+            )
+            await textEditorViewModel.discardDraft()
+            self.textEditorViewModel?.refreshMetadata(viewModel.metadataSnapshot)
+            await MainActor.run { isRenderingTextPage = false }
+            return true
+        } catch {
+            await MainActor.run {
+                isRenderingTextPage = false
+                textAppendErrorMessage = error.localizedDescription
+                showingTextAppendError = true
+            }
+            return false
+        }
+    }
+
+    @ViewBuilder
+    private var textEditorSheet: some View {
+        if let textEditorViewModel {
+            NavigationStack {
+                TextPageEditorView(viewModel: textEditorViewModel)
+                    .navigationTitle("Text Page")
+                    .navigationBarTitleDisplayMode(.inline)
+                    .toolbar {
+                        ToolbarItem(placement: .cancellationAction) {
+                            let canDiscard = (textEditorViewModel.state != .empty)
+                            Button("Discard") {
+                                Task {
+                                    await textEditorViewModel.discardDraft()
+                                    showTextEditor = false
+                                }
+                            }
+                            .disabled(!canDiscard)
+                        }
+
+                        ToolbarItem(placement: .confirmationAction) {
+                            Button("Done") {
+                                showTextEditor = false
+                            }
+                        }
+                    }
+            }
+        } else {
+            VStack {
+                ProgressView()
+                Text("Preparing editorâ€¦")
+                    .foregroundColor(.secondary)
+                    .padding(.top, 8)
+            }
+            .padding()
+        }
+    }
     
     private func loadDocument() async {
         let loadedDocument = NoteDocument(fileURL: documentURL)
@@ -309,6 +458,31 @@ struct DocumentEditView: View {
                     if success {
                         self.document = loadedDocument
                         self.viewModel = DocumentViewModel(document: loadedDocument)
+
+                        let metadata = loadedDocument.metadata
+                        let textVM = TextPageEditorViewModel(documentURL: documentURL, metadata: metadata)
+                        textVM.onDraftStateChange = { hasDraft in
+                            Task { @MainActor in
+                                self.viewModel?.updatePendingTextPageFlag(hasDraft)
+                            }
+                        }
+                        self.textEditorViewModel = textVM
+
+                        Task {
+                            await textVM.loadDraftIfAvailable()
+                            let manager = TextPageDraftManager.shared
+                            let draftExists = await manager.hasDraft(for: documentURL, metadata: metadata)
+                            if draftExists {
+                                await MainActor.run {
+                                    self.viewModel?.updatePendingTextPageFlag(true)
+                                    self.showTextEditor = true
+                                }
+                            } else if metadata.hasPendingTextPage {
+                                await MainActor.run {
+                                    self.showTextEditor = true
+                                }
+                            }
+                        }
                     }
                     self.isLoading = false
                     continuation.resume()
diff --git a/Yiana/Yiana/Views/DocumentListView.swift b/Yiana/Yiana/Views/DocumentListView.swift
index 5510094..8252e6b 100644
--- a/Yiana/Yiana/Views/DocumentListView.swift
+++ b/Yiana/Yiana/Views/DocumentListView.swift
@@ -45,330 +45,31 @@ struct DocumentListView: View {
     
     var body: some View {
         NavigationStack(path: $navigationPath) {
-            Group {
-                if viewModel.isLoading && viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty {
-                    ProgressView("Loading documents...")
-                        .frame(maxWidth: .infinity, maxHeight: .infinity)
-                } else if viewModel.isSearchInProgress && viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty && viewModel.otherFolderResults.isEmpty {
-                    // Show searching indicator when no results yet but still searching
-                    VStack(spacing: 20) {
-                        ProgressView()
-                            .scaleEffect(1.5)
-                        Text("Searching...")
-                            .font(.headline)
-                            .foregroundColor(.secondary)
-                    }
-                    .frame(maxWidth: .infinity, maxHeight: .infinity)
-                } else if viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty && viewModel.otherFolderResults.isEmpty && !viewModel.isSearchInProgress {
-                    emptyStateView
-                } else {
-                    documentList
-                }
-            }
-            .navigationTitle(viewModel.currentFolderName)
-            .toolbar {
-                // Back button for subfolder navigation
-                if !viewModel.folderPath.isEmpty {
-                    #if os(iOS)
-                    ToolbarItem(placement: .navigationBarLeading) {
-                        Button(action: {
-                            Task {
-                                await viewModel.navigateToParent()
-                            }
-                        }) {
-                            Label("Back", systemImage: "chevron.left")
-                        }
-                    }
-                    #else
-                    ToolbarItem(placement: .navigation) {
-                        Button(action: {
-                            Task {
-                                await viewModel.navigateToParent()
-                            }
-                        }) {
-                            Label("Back", systemImage: "chevron.left")
-                        }
-                    }
-                    #endif
-                }
-                
-                // Create menu
-                ToolbarItem(placement: .primaryAction) {
-                    Menu {
-                        Button(action: { showingCreateAlert = true }) {
-                            Label("New Document", systemImage: "doc")
-                        }
-                        Button(action: { showingFolderAlert = true }) {
-                            Label("New Folder", systemImage: "folder.badge.plus")
-                        }
-                        #if os(macOS)
-                        Divider()
-                        Button(action: { selectPDFsForImport() }) {
-                            Label("Import PDFs...", systemImage: "square.and.arrow.down.on.square")
-                        }
-                        .keyboardShortcut("I", modifiers: [.command, .shift])
-                        #endif
-                    } label: {
-                        Label("Add", systemImage: "plus")
-                    }
-                }
-
-                // Sort menu
-                ToolbarItem(placement: .automatic) {
-                    Menu {
-                        Section("Sort By") {
-                            Button(action: {
-                                currentSortOption = .title
-                                Task {
-                                    await viewModel.sortDocuments(by: .title, ascending: isAscending)
-                                }
-                            }) {
-                                HStack {
-                                    Text("Title")
-                                    if currentSortOption == .title {
-                                        Spacer()
-                                        Image(systemName: "checkmark")
-                                    }
-                                }
-                            }
-
-                            Button(action: {
-                                currentSortOption = .dateModified
-                                Task {
-                                    await viewModel.sortDocuments(by: .dateModified, ascending: isAscending)
-                                }
-                            }) {
-                                HStack {
-                                    Text("Date Modified")
-                                    if currentSortOption == .dateModified {
-                                        Spacer()
-                                        Image(systemName: "checkmark")
-                                    }
-                                }
-                            }
-
-                            Button(action: {
-                                currentSortOption = .dateCreated
-                                Task {
-                                    await viewModel.sortDocuments(by: .dateCreated, ascending: isAscending)
-                                }
-                            }) {
-                                HStack {
-                                    Text("Date Created")
-                                    if currentSortOption == .dateCreated {
-                                        Spacer()
-                                        Image(systemName: "checkmark")
-                                    }
-                                }
-                            }
-
-                            Button(action: {
-                                currentSortOption = .size
-                                Task {
-                                    await viewModel.sortDocuments(by: .size, ascending: isAscending)
-                                }
-                            }) {
-                                HStack {
-                                    Text("Size")
-                                    if currentSortOption == .size {
-                                        Spacer()
-                                        Image(systemName: "checkmark")
-                                    }
-                                }
-                            }
-                        }
-
-                        Divider()
-
-                        Button(action: {
-                            isAscending.toggle()
-                            Task {
-                                await viewModel.sortDocuments(by: currentSortOption, ascending: isAscending)
-                            }
-                        }) {
-                            Label(isAscending ? "Ascending" : "Descending",
-                                  systemImage: isAscending ? "arrow.up" : "arrow.down")
-                        }
-                    } label: {
-                        Label("Sort", systemImage: "arrow.up.arrow.down")
-                    }
-                }
-
-                // Download All button
-                ToolbarItem(placement: .automatic) {
-                    Button(action: {
-                        Task {
-                            await downloadAllDocuments()
-                        }
-                    }) {
-                        if downloadManager.isDownloading {
-                            HStack(spacing: 6) {
-                                ProgressView(value: downloadManager.downloadProgress)
-                                    .progressViewStyle(.circular)
-                                    .scaleEffect(0.9)
-                                Text("\(downloadManager.downloadedCount)/\(downloadManager.totalCount)")
-                                    .font(.caption)
-                                    .monospacedDigit()
-                            }
-                            .frame(minWidth: 80)
-                        } else {
-                            Label("Download All", systemImage: "icloud.and.arrow.down")
-                        }
-                    }
-                    .disabled(downloadManager.isDownloading)
-                }
-
-                #if os(macOS)
-                // Search field for macOS in toolbar
-                ToolbarItem(placement: .automatic) {
-                    HStack {
-                        Image(systemName: "magnifyingglass")
-                            .foregroundColor(.secondary)
-                        TextField("Search", text: $searchText)
-                            .textFieldStyle(.roundedBorder)
-                            .frame(width: 200)
-                            // Remove onSubmit - we use onChange for all search triggers
-                        if !searchText.isEmpty {
-                            Button(action: {
-                                searchText = ""
-                                // Clearing will be handled by onChange
-                            }) {
-                                Image(systemName: "xmark.circle.fill")
-                                    .foregroundColor(.secondary)
-                            }
-                            .buttonStyle(.plain)
-                        }
-                        // Show progress indicator during search
-                        if viewModel.isSearchInProgress {
-                            ProgressView()
-                                .scaleEffect(0.7)
-                                .frame(width: 16, height: 16)
-                        }
-                    }
-                }
-                #endif
-
-                // Development menu (DEBUG only)
-                #if DEBUG
-                ToolbarItem(placement: .automatic) {
-                    DevelopmentMenu()
-                }
-                #endif
-            }
-            .alert("New Document", isPresented: $showingCreateAlert) {
-                TextField("Document Title", text: $newDocumentTitle)
-                Button("Cancel", role: .cancel) {
-                    newDocumentTitle = ""
-                }
-                Button("Create") {
-                    createDocument()
-                }
-            }
-            .alert("Error", isPresented: $showingError) {
-                Button("OK") { }
-            } message: {
-                Text(viewModel.errorMessage ?? "An error occurred")
-            }
-            .alert("New Folder", isPresented: $showingFolderAlert) {
-                TextField("Folder Name", text: $newFolderName)
-                Button("Cancel", role: .cancel) {
-                    newFolderName = ""
-                }
-                Button("Create") {
-                    createFolder()
-                }
-            }
-            .alert("Delete Document", isPresented: $showingDeleteConfirmation) {
-                Button("Cancel", role: .cancel) {
-                    documentToDelete = nil
-                }
-                Button("Delete", role: .destructive) {
-                    if let url = documentToDelete {
-                        Task {
-                            do {
-                                try await viewModel.deleteDocument(at: url)
-                            } catch {
-                                viewModel.errorMessage = error.localizedDescription
-                                showingError = true
-                            }
-                        }
-                    }
-                    documentToDelete = nil
-                }
-            } message: {
-                Text("Are you sure you want to delete this document? This action cannot be undone.")
-            }
-            .navigationDestination(for: URL.self) { url in
-                #if os(iOS)
-                DocumentEditView(documentURL: url)
-                #else
-                DocumentReadView(documentURL: url)
-                #endif
-            }
-            .navigationDestination(for: DocumentNavigationData.self) { navData in
-                #if os(iOS)
-                DocumentEditView(documentURL: navData.url)
-                #else
-                DocumentReadView(
-                    documentURL: navData.url,
-                    searchResult: navData.searchResult
-                )
-                #endif
-            }
-        }
-        .task {
-            await viewModel.loadDocuments()
+            mainContent
+                .navigationTitle(viewModel.currentFolderName)
+                .toolbar { toolbarContent }
+                .alert("New Document", isPresented: $showingCreateAlert, actions: newDocumentAlertActions)
+                .alert("Error", isPresented: $showingError, actions: errorAlertActions, message: errorAlertMessage)
+                .alert("New Folder", isPresented: $showingFolderAlert, actions: newFolderAlertActions)
+                .alert("Delete Document", isPresented: $showingDeleteConfirmation, actions: deleteDocumentAlertActions, message: deleteDocumentAlertMessage)
+                .navigationDestination(for: URL.self, destination: navigationDestination)
+                .navigationDestination(for: DocumentNavigationData.self, destination: navigationDestinationForDocument)
         }
+        .task { await loadDocuments() }
         .onReceive(NotificationCenter.default.publisher(for: Notification.Name.yianaDocumentsChanged)) { _ in
             Task { await viewModel.refresh() }
         }
-        .refreshable {
-            await viewModel.refresh()
-        }
-        #if os(iOS)
+        .refreshable { await refreshDocuments() }
+#if os(iOS)
         .searchable(text: $searchText, prompt: "Search documents")
-        #endif
+#endif
         .onChange(of: searchText) { _, newValue in
-            Task {
-                await viewModel.filterDocuments(searchText: newValue)
-            }
+            handleSearchChange(newValue)
         }
-        #if os(macOS)
-        .sheet(item: $pdfImportData) { data in
-            BulkImportView(
-                pdfURLs: data.urls,
-                folderPath: viewModel.folderPath.joined(separator: "/"),
-                isPresented: .constant(false),
-                onDismiss: {
-                    pdfImportData = nil
-                }
-            )
-        }
-        .onDrop(of: [.pdf], isTargeted: $isDraggingPDFs) { providers in
-            handleDrop(providers: providers)
-        }
-        .overlay(
-            Group {
-                if isDraggingPDFs {
-                    ZStack {
-                        Color.accentColor.opacity(0.1)
-                        RoundedRectangle(cornerRadius: 12)
-                            .stroke(Color.accentColor, lineWidth: 3)
-                            .padding(20)
-                        VStack(spacing: 12) {
-                            Image(systemName: "arrow.down.doc.fill")
-                                .font(.system(size: 48))
-                                .foregroundColor(.accentColor)
-                            Text("Drop PDFs to import")
-                                .font(.title2)
-                                .fontWeight(.semibold)
-                                .foregroundColor(.accentColor)
-                        }
-                    }
-                    .ignoresSafeArea()
-                }
-            }
-        )
+#if os(macOS)
+        .sheet(item: $pdfImportData, content: bulkImportSheet)
+        .onDrop(of: [.pdf], isTargeted: $isDraggingPDFs, perform: handleDrop)
+        .overlay(macDragOverlay)
         #endif
     }
     
@@ -396,136 +97,25 @@ struct DocumentListView: View {
         }
         .frame(maxWidth: .infinity, maxHeight: .infinity)
     }
-    
-    private var documentList: some View {
-        VStack(spacing: 0) {
-            // Breadcrumb navigation
-            if !viewModel.folderPath.isEmpty {
-                breadcrumbView
-                    .padding(.horizontal)
-                    .padding(.vertical, 8)
-                Divider()
-            }
-            
-            // Show search progress indicator for iOS
-            #if os(iOS)
-            if viewModel.isSearchInProgress {
-                HStack {
-                    ProgressView()
-                        .scaleEffect(0.8)
-                    Text("Searching...")
-                        .font(.caption)
-                        .foregroundColor(.secondary)
-                }
-                .padding(.vertical, 8)
-            }
-            #endif
-            
-            List {
 
-                // Folders section
-                if !viewModel.folderURLs.isEmpty {
-                Section("Folders") {
-                    ForEach(viewModel.folderURLs, id: \.self) { folderURL in
-                        Button(action: {
-                            Task {
-                                await viewModel.navigateToFolder(folderURL.lastPathComponent)
-                            }
-                        }) {
-                            HStack {
-                                Image(systemName: "folder.fill")
-                                    .foregroundColor(.accentColor)
-                                    .font(.title3)
-                                Text(folderURL.lastPathComponent)
-                                    .foregroundColor(.primary)
-                                Spacer()
-                                Image(systemName: "chevron.right")
-                                    .foregroundColor(.secondary)
-                                    .font(.caption)
-                            }
-                            .contentShape(Rectangle())
-                        }
-                        .buttonStyle(.plain)
-                    }
-                }
-            }
-            
-            // Documents section
-            if !viewModel.documentURLs.isEmpty {
-                Section(viewModel.isSearching ? "In This Folder" : "Documents") {
-                    ForEach(viewModel.documentURLs, id: \.self) { url in
-                        let searchResult = viewModel.searchResults.first { $0.documentURL == url }
-                        Group {
-                            if let result = searchResult {
-                                NavigationLink(value: DocumentNavigationData(url: url, searchResult: result)) {
-                                    DocumentRow(url: url, searchResult: result)
-                                }
-                            } else {
-                                NavigationLink(value: url) {
-                                    DocumentRow(url: url, searchResult: nil)
-                                }
-                            }
-                        }
-                        .swipeActions(edge: .leading, allowsFullSwipe: true) {
-                            Button {
-                                duplicateDocument(url)
-                            } label: {
-                                Label("Duplicate", systemImage: "doc.on.doc")
-                            }
-                            .tint(.indigo)
-                        }
-                        .swipeActions(edge: .trailing, allowsFullSwipe: false) {
-                            Button(role: .destructive) {
-                                documentToDelete = url
-                                showingDeleteConfirmation = true
-                            } label: {
-                                Label("Delete", systemImage: "trash")
-                            }
-                        }
-                    }
-                    .onDelete(perform: deleteDocuments)
-                }
-            }
-            
-            // Other folders section (only when searching)
-            if viewModel.isSearching && !viewModel.otherFolderResults.isEmpty {
-                Section("In Other Folders") {
-                    ForEach(viewModel.otherFolderResults, id: \.url) { result in
-                        let searchResult = viewModel.searchResults.first { $0.documentURL == result.url }
-                        NavigationLink(value: DocumentNavigationData(url: result.url, searchResult: searchResult)) {
-                            DocumentRow(
-                                url: result.url,
-                                searchResult: searchResult,
-                                secondaryText: result.path
-                            )
-                        }
-                    }
-                }
-            }
-            
-            // Version info section at the bottom
-            Section {
-                HStack {
-                    Spacer()
-                    VStack(spacing: 4) {
-                        if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String,
-                           let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
-                            Text("Version \(version) (\(build))")
-                                .font(.caption2)
-                                .foregroundColor(.secondary)
-                        }
-                        Text("Build Date: \(buildDateString)")
-                            .font(.caption2)
-                            .foregroundColor(.secondary)
-                    }
-                    Spacer()
-                }
-                .listRowBackground(Color.clear)
-            }
+    @ViewBuilder
+    private var mainContent: some View {
+        if viewModel.isLoading && viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty {
+            ProgressView("Loading documents...")
+                .frame(maxWidth: .infinity, maxHeight: .infinity)
+        } else if viewModel.isSearchInProgress && viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty && viewModel.otherFolderResults.isEmpty {
+            VStack(spacing: 20) {
+                ProgressView()
+                    .scaleEffect(1.5)
+                Text("Searching...")
+                    .font(.headline)
+                    .foregroundColor(.secondary)
             }
-            #if os(iOS)
-            .listStyle(.insetGrouped)
-            #endif
+            .frame(maxWidth: .infinity, maxHeight: .infinity)
+        } else if viewModel.documentURLs.isEmpty && viewModel.folderURLs.isEmpty && viewModel.otherFolderResults.isEmpty && !viewModel.isSearchInProgress {
+            emptyStateView
+        } else {
+            documentList
         }
     }
     
@@ -537,16 +127,15 @@ struct DocumentListView: View {
                 #if os(iOS)
                 // Create the actual document
                 let document = NoteDocument(fileURL: url)
-                document.save(to: url, for: .forCreating) { success in
-                    Task { @MainActor in
-                        if success {
-                            await viewModel.refresh()
-                            navigationPath.append(url)
-                        } else {
-                            viewModel.errorMessage = "Failed to create document"
-                            showingError = true
-                        }
+                let success = await document.save(to: url, for: .forCreating)
+                if success {
+                    await viewModel.refresh()
+                    await MainActor.run {
+                        navigationPath.append(url)
                     }
+                } else {
+                    viewModel.errorMessage = "Failed to create document"
+                    showingError = true
                 }
                 #else
                 // macOS: Create a valid NoteDocument structure
@@ -615,6 +204,423 @@ struct DocumentListView: View {
         downloadManager.downloadAllDocuments(urls: urls)
     }
 
+    @ViewBuilder
+    private func newDocumentAlertActions() -> some View {
+        TextField("Document Title", text: $newDocumentTitle)
+        Button("Cancel", role: .cancel) {
+            newDocumentTitle = ""
+        }
+        Button("Create") {
+            createDocument()
+        }
+    }
+
+    @ViewBuilder
+    private func errorAlertActions() -> some View {
+        Button("OK") { }
+    }
+
+    @ViewBuilder
+    private func errorAlertMessage() -> some View {
+        Text(viewModel.errorMessage ?? "An error occurred")
+    }
+
+    @ViewBuilder
+    private func newFolderAlertActions() -> some View {
+        TextField("Folder Name", text: $newFolderName)
+        Button("Cancel", role: .cancel) {
+            newFolderName = ""
+        }
+        Button("Create") {
+            createFolder()
+        }
+    }
+
+    @ViewBuilder
+    private func deleteDocumentAlertActions() -> some View {
+        Button("Cancel", role: .cancel) {
+            documentToDelete = nil
+        }
+        Button("Delete", role: .destructive) {
+            if let url = documentToDelete {
+                Task {
+                    do {
+                        try await viewModel.deleteDocument(at: url)
+                    } catch {
+                        viewModel.errorMessage = error.localizedDescription
+                        showingError = true
+                    }
+                }
+            }
+            documentToDelete = nil
+        }
+    }
+
+    @ViewBuilder
+    private func deleteDocumentAlertMessage() -> some View {
+        Text("Are you sure you want to delete this document? This action cannot be undone.")
+    }
+
+    @ViewBuilder
+    private func navigationDestination(_ url: URL) -> some View {
+        #if os(iOS)
+        DocumentEditView(documentURL: url)
+        #else
+        DocumentReadView(documentURL: url)
+        #endif
+    }
+
+    @ViewBuilder
+    private func navigationDestinationForDocument(_ data: DocumentNavigationData) -> some View {
+        #if os(iOS)
+        DocumentEditView(documentURL: data.url)
+        #else
+        DocumentReadView(documentURL: data.url, searchResult: data.searchResult)
+        #endif
+    }
+
+    private func loadDocuments() async {
+        await viewModel.loadDocuments()
+    }
+
+    private func refreshDocuments() async {
+        await viewModel.refresh()
+    }
+
+    private func handleSearchChange(_ newValue: String) {
+        Task {
+            await viewModel.filterDocuments(searchText: newValue)
+        }
+    }
+
+    #if os(macOS)
+    private func bulkImportSheet(data: PDFImportData) -> some View {
+        BulkImportView(
+            pdfURLs: data.urls,
+            folderPath: viewModel.folderPath.joined(separator: "/"),
+            isPresented: .constant(false),
+            onDismiss: { pdfImportData = nil }
+        )
+    }
+
+    private var macDragOverlay: some View {
+        Group {
+            if isDraggingPDFs {
+                ZStack {
+                    Color.accentColor.opacity(0.1)
+                    RoundedRectangle(cornerRadius: 12)
+                        .stroke(Color.accentColor, lineWidth: 3)
+                        .padding(20)
+                    VStack(spacing: 12) {
+                        Image(systemName: "arrow.down.doc.fill")
+                            .font(.system(size: 48))
+                            .foregroundColor(.accentColor)
+                        Text("Drop PDFs to import")
+                            .font(.title2)
+                            .fontWeight(.semibold)
+                            .foregroundColor(.accentColor)
+                    }
+                }
+                .ignoresSafeArea()
+            }
+        }
+    }
+
+    #endif
+
+    @ViewBuilder
+    private var documentList: some View {
+        VStack(spacing: 0) {
+            if !viewModel.folderPath.isEmpty {
+                breadcrumbView
+                    .padding(.horizontal)
+                    .padding(.vertical, 8)
+                Divider()
+            }
+
+            #if os(iOS)
+            if viewModel.isSearchInProgress {
+                iosSearchProgress
+            }
+            #endif
+
+            List {
+                foldersSection
+                documentsSection
+                otherFoldersSection
+                versionSection
+            }
+            #if os(iOS)
+            .listStyle(.insetGrouped)
+            #endif
+        }
+    }
+
+    #if os(iOS)
+    private var iosSearchProgress: some View {
+        HStack {
+            ProgressView()
+                .scaleEffect(0.8)
+            Text("Searching...")
+                .font(.caption)
+                .foregroundColor(.secondary)
+        }
+        .padding(.vertical, 8)
+    }
+    #endif
+
+    @ViewBuilder
+    private var foldersSection: some View {
+        if !viewModel.folderURLs.isEmpty {
+            Section("Folders") {
+                ForEach(viewModel.folderURLs, id: \.self) { folderURL in
+                    folderRow(for: folderURL)
+                }
+            }
+        }
+    }
+
+    @ViewBuilder
+    private var documentsSection: some View {
+        if !viewModel.documentURLs.isEmpty {
+            Section(viewModel.isSearching ? "In This Folder" : "Documents") {
+                ForEach(viewModel.documentURLs, id: \.self) { url in
+                    documentNavigationRow(for: url)
+                        .swipeActions(edge: .leading, allowsFullSwipe: true) {
+                            Button {
+                                duplicateDocument(url)
+                            } label: {
+                                Label("Duplicate", systemImage: "doc.on.doc")
+                            }
+                            .tint(.indigo)
+                        }
+                        .swipeActions(edge: .trailing, allowsFullSwipe: false) {
+                            Button(role: .destructive) {
+                                documentToDelete = url
+                                showingDeleteConfirmation = true
+                            } label: {
+                                Label("Delete", systemImage: "trash")
+                            }
+                        }
+                }
+                .onDelete(perform: deleteDocuments)
+            }
+        }
+    }
+
+    @ViewBuilder
+    private var otherFoldersSection: some View {
+        if viewModel.isSearching && !viewModel.otherFolderResults.isEmpty {
+            Section("In Other Folders") {
+                ForEach(viewModel.otherFolderResults, id: \.url) { result in
+                    let searchResult = viewModel.searchResults.first { $0.documentURL == result.url }
+                    NavigationLink(value: DocumentNavigationData(url: result.url, searchResult: searchResult)) {
+                        DocumentRow(
+                            url: result.url,
+                            searchResult: searchResult,
+                            secondaryText: result.path
+                        )
+                    }
+                }
+            }
+        }
+    }
+
+    private var versionSection: some View {
+        Section {
+            HStack {
+                Spacer()
+                VStack(spacing: 4) {
+                    if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String,
+                       let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
+                        Text("Version \(version) (\(build))")
+                            .font(.caption2)
+                            .foregroundColor(.secondary)
+                    }
+                    Text("Build Date: \(buildDateString)")
+                        .font(.caption2)
+                        .foregroundColor(.secondary)
+                }
+                Spacer()
+            }
+            .listRowBackground(Color.clear)
+        }
+    }
+
+    @ViewBuilder
+    private func folderRow(for folderURL: URL) -> some View {
+        Button(action: {
+            Task {
+                await viewModel.navigateToFolder(folderURL.lastPathComponent)
+            }
+        }) {
+            HStack {
+                Image(systemName: "folder.fill")
+                    .foregroundColor(.accentColor)
+                    .font(.title3)
+                Text(folderURL.lastPathComponent)
+                    .foregroundColor(.primary)
+                Spacer()
+                Image(systemName: "chevron.right")
+                    .foregroundColor(.secondary)
+                    .font(.caption)
+            }
+            .contentShape(Rectangle())
+        }
+        .buttonStyle(.plain)
+    }
+
+    @ViewBuilder
+    private func documentNavigationRow(for url: URL) -> some View {
+        let searchResult = viewModel.searchResults.first { $0.documentURL == url }
+        if let result = searchResult {
+            NavigationLink(value: DocumentNavigationData(url: url, searchResult: result)) {
+                DocumentRow(url: url, searchResult: result)
+            }
+        } else {
+            NavigationLink(value: url) {
+                DocumentRow(url: url, searchResult: nil)
+            }
+        }
+    }
+
+    @ToolbarContentBuilder
+    private var toolbarContent: some ToolbarContent {
+        if !viewModel.folderPath.isEmpty {
+            #if os(iOS)
+            ToolbarItem(placement: .navigationBarLeading) {
+                Button(action: navigateToParent) {
+                    Label("Back", systemImage: "chevron.left")
+                }
+            }
+            #else
+            ToolbarItem(placement: .navigation) {
+                Button(action: navigateToParent) {
+                    Label("Back", systemImage: "chevron.left")
+                }
+            }
+            #endif
+        }
+
+        ToolbarItem(placement: .primaryAction) {
+            Menu {
+                Button(action: { showingCreateAlert = true }) {
+                    Label("New Document", systemImage: "doc")
+                }
+                Button(action: { showingFolderAlert = true }) {
+                    Label("New Folder", systemImage: "folder.badge.plus")
+                }
+                #if os(macOS)
+                Divider()
+                Button(action: selectPDFsForImport) {
+                    Label("Import PDFs...", systemImage: "square.and.arrow.down.on.square")
+                }
+                .keyboardShortcut("I", modifiers: [.command, .shift])
+                #endif
+            } label: {
+                Label("Add", systemImage: "plus")
+            }
+        }
+
+        ToolbarItem(placement: .automatic) {
+            Menu {
+                Section("Sort By") {
+                    sortButton(label: "Title", option: .title)
+                    sortButton(label: "Date Modified", option: .dateModified)
+                    sortButton(label: "Date Created", option: .dateCreated)
+                    sortButton(label: "Size", option: .size)
+                }
+
+                Divider()
+
+                Button(action: toggleSortOrder) {
+                    Label(
+                        isAscending ? "Ascending" : "Descending",
+                        systemImage: isAscending ? "arrow.up" : "arrow.down"
+                    )
+                }
+            } label: {
+                Label("Sort", systemImage: "arrow.up.arrow.down")
+            }
+        }
+
+        ToolbarItem(placement: .automatic) {
+            Button(action: startDownloadAll) {
+                if downloadManager.isDownloading {
+                    HStack(spacing: 6) {
+                        ProgressView(value: downloadManager.downloadProgress)
+                            .progressViewStyle(.circular)
+                            .scaleEffect(0.9)
+                        Text("\(downloadManager.downloadedCount)/\(downloadManager.totalCount)")
+                            .font(.caption)
+                            .monospacedDigit()
+                    }
+                    .frame(minWidth: 80)
+                } else {
+                    Label("Download All", systemImage: "icloud.and.arrow.down")
+                }
+            }
+            .disabled(downloadManager.isDownloading)
+        }
+
+        #if os(macOS)
+        ToolbarItem(placement: .automatic) {
+            macSearchToolbar
+        }
+        #endif
+
+        #if DEBUG
+        ToolbarItem(placement: .automatic) {
+            DevelopmentMenu()
+        }
+        #endif
+    }
+
+    private func sortButton(label: String, option: SortOption) -> some View {
+        Button(action: { updateSort(option: option) }) {
+            HStack {
+                Text(label)
+                if currentSortOption == option {
+                    Spacer()
+                    Image(systemName: "checkmark")
+                }
+            }
+        }
+    }
+
+    private func updateSort(option: SortOption) {
+        currentSortOption = option
+        Task {
+            await viewModel.sortDocuments(by: option, ascending: isAscending)
+        }
+    }
+
+    private func toggleSortOrder() {
+        isAscending.toggle()
+        Task {
+            await viewModel.sortDocuments(by: currentSortOption, ascending: isAscending)
+        }
+    }
+
+    private func navigateToParent() {
+        Task {
+            await viewModel.navigateToParent()
+        }
+    }
+
+    private func startDownloadAll() {
+        Task {
+            await downloadAllDocuments()
+        }
+    }
+
+    private func clearSearch() {
+        searchText = ""
+        Task {
+            await viewModel.filterDocuments(searchText: "")
+        }
+    }
+
     private func createFolder() {
         Task {
             guard !newFolderName.isEmpty else { return }
@@ -663,6 +669,28 @@ struct DocumentListView: View {
     }
     
     #if os(macOS)
+    private var macSearchToolbar: some View {
+        HStack {
+            Image(systemName: "magnifyingglass")
+                .foregroundColor(.secondary)
+            TextField("Search", text: $searchText)
+                .textFieldStyle(.roundedBorder)
+                .frame(width: 200)
+            if !searchText.isEmpty {
+                Button(action: clearSearch) {
+                    Image(systemName: "xmark.circle.fill")
+                        .foregroundColor(.secondary)
+                }
+                .buttonStyle(.plain)
+            }
+            if viewModel.isSearchInProgress {
+                ProgressView()
+                    .scaleEffect(0.7)
+                    .frame(width: 16, height: 16)
+            }
+        }
+    }
+
     private func selectPDFsForImport() {
         let panel = NSOpenPanel()
         panel.allowedContentTypes = [.pdf]
diff --git a/Yiana/Yiana/Views/MacPDFViewer.swift b/Yiana/Yiana/Views/MacPDFViewer.swift
index 6a59f42..b302b83 100644
--- a/Yiana/Yiana/Views/MacPDFViewer.swift
+++ b/Yiana/Yiana/Views/MacPDFViewer.swift
@@ -41,7 +41,7 @@ struct MacPDFViewer: View {
                     }
                     .frame(width: 200)
                     .background(Color(NSColor.controlBackgroundColor))
-                    .onChange(of: currentPage) { newPage in
+                    .onChange(of: currentPage) { _, newPage in
                         withAnimation {
                             scrollProxy.scrollTo(newPage, anchor: .center)
                         }
@@ -252,4 +252,4 @@ struct ThumbnailView: View {
         return image
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/Yiana/Yiana/Views/MarkdownTextEditor.swift b/Yiana/Yiana/Views/MarkdownTextEditor.swift
new file mode 100644
index 0000000..57a9108
--- /dev/null
+++ b/Yiana/Yiana/Views/MarkdownTextEditor.swift
@@ -0,0 +1,507 @@
+//
+//  MarkdownTextEditor.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  SwiftUI wrapper around a platform-native text view that supports Markdown
+//  syntax highlighting and a small formatting toolbar. The bridge exposes the
+//  underlying selection so higher-level views can trigger formatting actions.
+//
+
+import SwiftUI
+
+#if os(iOS)
+import UIKit
+
+struct MarkdownTextEditor: UIViewRepresentable {
+    @Binding var text: String
+    @Binding var cursorPosition: Int?
+    @Binding var pendingAction: TextPageEditorAction?
+
+    var onEditingBegan: (() -> Void)?
+    var onEditingEnded: (() -> Void)?
+
+    func makeCoordinator() -> Coordinator {
+        Coordinator(parent: self)
+    }
+
+    func makeUIView(context: Context) -> UITextView {
+        let textView = UITextView()
+        textView.delegate = context.coordinator
+        textView.backgroundColor = .systemBackground
+        textView.isEditable = true
+        textView.isSelectable = true
+        textView.allowsEditingTextAttributes = false
+        textView.alwaysBounceVertical = true
+        textView.keyboardDismissMode = .interactive
+        textView.autocapitalizationType = .sentences
+        textView.smartDashesType = .yes
+        textView.smartQuotesType = .yes
+        textView.smartInsertDeleteType = .yes
+        textView.textContainerInset = UIEdgeInsets(top: 16, left: 20, bottom: 16, right: 20)
+        textView.typingAttributes = context.coordinator.baseTypingAttributes
+        textView.attributedText = context.coordinator.highlightedAttributedString(for: text)
+        return textView
+    }
+
+    func updateUIView(_ uiView: UITextView, context: Context) {
+        if context.coordinator.isUpdatingFromCoordinator == false,
+           uiView.text != text {
+            context.coordinator.isUpdatingFromParent = true
+            uiView.attributedText = context.coordinator.highlightedAttributedString(for: text)
+            if let cursorPosition {
+                uiView.selectedRange = NSRange(location: cursorPosition, length: 0)
+            }
+            context.coordinator.isUpdatingFromParent = false
+        }
+
+        if let action = pendingAction {
+            context.coordinator.apply(action: action, to: uiView)
+            DispatchQueue.main.async {
+                self.pendingAction = nil
+            }
+        }
+    }
+
+    final class Coordinator: NSObject, UITextViewDelegate {
+        private(set) var highlighter = MarkdownSyntaxHighlighter()
+        var parent: MarkdownTextEditor
+        var isUpdatingFromParent = false
+        var isUpdatingFromCoordinator = false
+
+        var baseTypingAttributes: [NSAttributedString.Key: Any] {
+            highlighter.baseTextAttributes()
+        }
+
+        init(parent: MarkdownTextEditor) {
+            self.parent = parent
+        }
+
+        func textViewDidBeginEditing(_ textView: UITextView) {
+            parent.onEditingBegan?()
+        }
+
+        func textViewDidEndEditing(_ textView: UITextView) {
+            parent.onEditingEnded?()
+        }
+
+        func textViewDidChange(_ textView: UITextView) {
+            guard !isUpdatingFromParent else { return }
+            isUpdatingFromCoordinator = true
+            parent.text = textView.text ?? ""
+            parent.cursorPosition = textView.selectedRange.location
+            applyHighlight(on: textView)
+            isUpdatingFromCoordinator = false
+        }
+
+        func textViewDidChangeSelection(_ textView: UITextView) {
+            parent.cursorPosition = textView.selectedRange.location
+        }
+
+        func highlightedAttributedString(for text: String) -> NSAttributedString {
+            let attributed = NSMutableAttributedString(string: text)
+            highlighter.applyHighlighting(to: attributed)
+            return attributed
+        }
+
+        func applyHighlight(on textView: UITextView) {
+            let selectedRange = textView.selectedRange
+            let attributed = NSMutableAttributedString(string: textView.text ?? "")
+            highlighter.applyHighlighting(to: attributed)
+            textView.attributedText = attributed
+            textView.selectedRange = selectedRange
+            textView.typingAttributes = baseTypingAttributes
+        }
+
+        func apply(action: TextPageEditorAction, to textView: UITextView) {
+            isUpdatingFromCoordinator = true
+            defer { isUpdatingFromCoordinator = false }
+
+            guard let currentText = textView.text else { return }
+            var newText = currentText
+            var newCursor = textView.selectedRange
+
+            switch action {
+            case .bold:
+                let result = wrapSelection(in: currentText, range: newCursor, prefix: "**", suffix: "**")
+                newText = result.text
+                newCursor = result.cursor
+            case .italic:
+                let result = wrapSelection(in: currentText, range: newCursor, prefix: "*", suffix: "*")
+                newText = result.text
+                newCursor = result.cursor
+            case .unorderedList:
+                let result = toggleList(in: currentText, range: newCursor, markerProvider: { _ in "- " })
+                newText = result.text
+                newCursor = result.cursor
+            case .orderedList:
+                let result = toggleList(in: currentText, range: newCursor, markerProvider: { index in "\(index + 1). " })
+                newText = result.text
+                newCursor = result.cursor
+            case .blockquote:
+                let result = toggleBlockquote(in: currentText, range: newCursor)
+                newText = result.text
+                newCursor = result.cursor
+            case .horizontalRule:
+                let result = insertHorizontalRule(in: currentText, range: newCursor)
+                newText = result.text
+                newCursor = result.cursor
+            case .heading(let level):
+                let result = applyHeading(in: currentText, range: newCursor, level: level)
+                newText = result.text
+                newCursor = result.cursor
+            }
+
+            parent.text = newText
+            parent.cursorPosition = newCursor.location
+
+            textView.text = newText
+            textView.selectedRange = newCursor
+            applyHighlight(on: textView)
+        }
+
+    }
+}
+
+#elseif os(macOS)
+
+import AppKit
+
+struct MarkdownTextEditor: NSViewRepresentable {
+    @Binding var text: String
+    @Binding var cursorPosition: Int?
+    @Binding var pendingAction: TextPageEditorAction?
+
+    var onEditingBegan: (() -> Void)?
+    var onEditingEnded: (() -> Void)?
+
+    func makeCoordinator() -> Coordinator {
+        Coordinator(parent: self)
+    }
+
+    func makeNSView(context: Context) -> NSScrollView {
+        let textView = NSTextView()
+        textView.delegate = context.coordinator
+        textView.isEditable = true
+        textView.isSelectable = true
+        textView.backgroundColor = .textBackgroundColor
+        textView.font = NSFont.preferredFont(forTextStyle: .body)
+        textView.textContainerInset = NSSize(width: 20, height: 16)
+        textView.allowsUndo = true
+        textView.isRichText = false
+
+        let scrollView = NSScrollView()
+        scrollView.hasVerticalScroller = true
+        scrollView.documentView = textView
+
+        context.coordinator.textView = textView
+        textView.string = text
+        context.coordinator.applyHighlight()
+
+        return scrollView
+    }
+
+    func updateNSView(_ nsView: NSScrollView, context: Context) {
+        guard let textView = context.coordinator.textView else { return }
+
+        if !context.coordinator.isUpdatingFromCoordinator,
+           textView.string != text {
+            context.coordinator.isUpdatingFromParent = true
+            textView.string = text
+            context.coordinator.applyHighlight()
+            if let cursorPosition {
+                let location = min(cursorPosition, textView.string.utf16.count)
+                textView.selectedRange = NSRange(location: location, length: 0)
+            }
+            context.coordinator.isUpdatingFromParent = false
+        }
+
+        if let action = pendingAction,
+           let textView = context.coordinator.textView {
+            context.coordinator.apply(action: action)
+            DispatchQueue.main.async {
+                self.pendingAction = nil
+            }
+            textView.window?.makeFirstResponder(textView)
+        }
+    }
+
+    final class Coordinator: NSObject, NSTextViewDelegate {
+        var parent: MarkdownTextEditor
+        let highlighter = MarkdownSyntaxHighlighter()
+        weak var textView: NSTextView?
+        var isUpdatingFromParent = false
+        var isUpdatingFromCoordinator = false
+
+        init(parent: MarkdownTextEditor) {
+            self.parent = parent
+        }
+
+        func textDidBeginEditing(_ notification: Notification) {
+            parent.onEditingBegan?()
+        }
+
+        func textDidEndEditing(_ notification: Notification) {
+            parent.onEditingEnded?()
+        }
+
+        func textDidChange(_ notification: Notification) {
+            guard !isUpdatingFromParent,
+                  let textView = textView else { return }
+
+            isUpdatingFromCoordinator = true
+            parent.text = textView.string
+            parent.cursorPosition = textView.selectedRange.location
+            applyHighlight()
+            isUpdatingFromCoordinator = false
+        }
+
+        func textViewDidChangeSelection(_ notification: Notification) {
+            guard let textView = textView else { return }
+            parent.cursorPosition = textView.selectedRange.location
+        }
+
+        func applyHighlight() {
+            guard let textView = textView else { return }
+            let mutable = NSMutableAttributedString(string: textView.string)
+            highlighter.applyHighlighting(to: mutable)
+            textView.textStorage?.setAttributedString(mutable)
+        }
+
+        func apply(action: TextPageEditorAction) {
+            guard let textView = textView else { return }
+            isUpdatingFromCoordinator = true
+            var currentText = textView.string
+            var selectedRange = textView.selectedRange
+
+            switch action {
+            case .bold:
+                let result = wrapSelection(in: currentText, range: selectedRange, prefix: "**", suffix: "**")
+                currentText = result.text
+                selectedRange = result.cursor
+            case .italic:
+                let result = wrapSelection(in: currentText, range: selectedRange, prefix: "*", suffix: "*")
+                currentText = result.text
+                selectedRange = result.cursor
+            case .unorderedList:
+                let result = toggleList(in: currentText, range: selectedRange, markerProvider: { _ in "- " })
+                currentText = result.text
+                selectedRange = result.cursor
+            case .orderedList:
+                let result = toggleList(in: currentText, range: selectedRange, markerProvider: { index in "\(index + 1). " })
+                currentText = result.text
+                selectedRange = result.cursor
+            case .blockquote:
+                let result = toggleBlockquote(in: currentText, range: selectedRange)
+                currentText = result.text
+                selectedRange = result.cursor
+            case .horizontalRule:
+                let result = insertHorizontalRule(in: currentText, range: selectedRange)
+                currentText = result.text
+                selectedRange = result.cursor
+            case .heading(let level):
+                let result = applyHeading(in: currentText, range: selectedRange, level: level)
+                currentText = result.text
+                selectedRange = result.cursor
+            }
+
+            parent.text = currentText
+            parent.cursorPosition = selectedRange.location
+
+            textView.string = currentText
+            textView.selectedRange = selectedRange
+            applyHighlight()
+            isUpdatingFromCoordinator = false
+        }
+    }
+}
+
+#endif
+
+#if os(iOS) || os(macOS)
+
+fileprivate let orderedListPrefixRegex = try? NSRegularExpression(pattern: "^\\d+\\.\\s+", options: [])
+
+fileprivate func wrapSelection(in text: String, range: NSRange, prefix: String, suffix: String) -> (text: String, cursor: NSRange) {
+    let nsText = text as NSString
+    let selectedText = nsText.substring(with: range)
+    let replacement: String
+    let newLocation: Int
+
+    if range.length > 0 {
+        replacement = "\(prefix)\(selectedText)\(suffix)"
+        newLocation = range.location + prefix.count + selectedText.count
+    } else {
+        replacement = "\(prefix)\(suffix)"
+        newLocation = range.location + prefix.count
+    }
+
+    let newText = nsText.replacingCharacters(in: range, with: replacement)
+    let boundedLocation = max(0, min(newLocation, (newText as NSString).length))
+    return (newText, NSRange(location: boundedLocation, length: 0))
+}
+
+fileprivate func toggleList(
+    in text: String,
+    range: NSRange,
+    markerProvider: (Int) -> String
+) -> (text: String, cursor: NSRange) {
+    let nsText = text as NSString
+    let lineRange = nsText.lineRange(for: range)
+    let selectedText = nsText.substring(with: lineRange)
+
+    var lines = selectedText.components(separatedBy: "\n")
+    let hadTrailingNewline = lines.last == ""
+    if hadTrailingNewline {
+        lines.removeLast()
+    }
+
+    guard !lines.isEmpty else { return (text, range) }
+
+    let markersApplied = lines.enumerated().allSatisfy { index, line in
+        let marker = markerProvider(index)
+        let trimmed = line.trimmingCharacters(in: .whitespaces)
+        guard !trimmed.isEmpty else { return false }
+
+        if marker.contains(".") {
+            return orderedListPrefixRegex?.firstMatch(
+                in: trimmed,
+                options: [],
+                range: NSRange(location: 0, length: trimmed.utf16.count)
+            ) != nil
+        } else {
+            let trimmedMarker = marker.trimmingCharacters(in: .whitespaces)
+            return trimmed.hasPrefix(trimmedMarker)
+        }
+    }
+
+    let updatedLines: [String] = lines.enumerated().map { index, line in
+        let indentation = line.prefix { $0 == " " || $0 == "\t" }
+        let indentationString = String(indentation)
+        var remainder = String(line.dropFirst(indentation.count))
+        let marker = markerProvider(index)
+        let trimmedMarker = marker.trimmingCharacters(in: .whitespaces)
+        let trimmedRemainder = remainder.trimmingCharacters(in: .whitespaces)
+
+        guard !trimmedRemainder.isEmpty else { return String(line) }
+
+        if markersApplied {
+            if marker.contains(".") {
+                if let match = orderedListPrefixRegex?.firstMatch(
+                    in: trimmedRemainder,
+                    options: [],
+                    range: NSRange(location: 0, length: trimmedRemainder.utf16.count)
+                ) {
+                    var mutable = trimmedRemainder
+                    let start = mutable.index(mutable.startIndex, offsetBy: match.range.length)
+                    mutable = String(mutable[start...]).trimmingCharacters(in: .whitespaces)
+                    return indentationString + mutable
+                }
+                return String(line)
+            }
+
+            if remainder.hasPrefix(trimmedMarker) {
+                remainder.removeFirst(trimmedMarker.count)
+                let trimmed = remainder.drop { $0 == " " }
+                return indentationString + String(trimmed)
+            }
+            return String(line)
+        } else {
+            let content = trimmedRemainder
+            return indentationString + markerProvider(index) + content
+        }
+    }
+
+    var replacement = updatedLines.joined(separator: "\n")
+    if hadTrailingNewline {
+        replacement.append("\n")
+    }
+
+    let newText = nsText.replacingCharacters(in: lineRange, with: replacement)
+    let location = min(lineRange.location + replacement.count, (newText as NSString).length)
+    return (newText, NSRange(location: location, length: 0))
+}
+
+fileprivate func toggleBlockquote(in text: String, range: NSRange) -> (text: String, cursor: NSRange) {
+    let nsText = text as NSString
+    let lineRange = nsText.lineRange(for: range)
+    let selectedText = nsText.substring(with: lineRange)
+
+    var lines = selectedText.components(separatedBy: "\n")
+    let hadTrailingNewline = lines.last == ""
+    if hadTrailingNewline { lines.removeLast() }
+
+    guard !lines.isEmpty else { return (text, range) }
+
+    let markersApplied = lines.allSatisfy { line in
+        line.trimmingCharacters(in: .whitespaces).hasPrefix(">")
+    }
+
+    let updatedLines = lines.map { line -> String in
+        let indentation = line.prefix { $0 == " " || $0 == "\t" }
+        let indentationString = String(indentation)
+        var remainder = String(line.dropFirst(indentation.count))
+        let trimmed = remainder.trimmingCharacters(in: .whitespaces)
+        guard !trimmed.isEmpty else { return String(line) }
+
+        if markersApplied {
+            if remainder.hasPrefix("> ") {
+                remainder.removeFirst(2)
+            } else if remainder.hasPrefix(">") {
+                remainder.removeFirst()
+                if remainder.first == " " { remainder.removeFirst() }
+            }
+            return indentationString + remainder
+        } else {
+            return indentationString + "> " + trimmed
+        }
+    }
+
+    var replacement = updatedLines.joined(separator: "\n")
+    if hadTrailingNewline { replacement.append("\n") }
+
+    let newText = nsText.replacingCharacters(in: lineRange, with: replacement)
+    let location = min(lineRange.location, (newText as NSString).length)
+    return (newText, NSRange(location: location, length: 0))
+}
+
+fileprivate func insertHorizontalRule(in text: String, range: NSRange) -> (text: String, cursor: NSRange) {
+    let nsText = text as NSString
+    let insertion = "\n\n---\n\n"
+    let newText = nsText.replacingCharacters(in: range, with: insertion)
+    let location = min(range.location + insertion.count, (newText as NSString).length)
+    return (newText, NSRange(location: location, length: 0))
+}
+
+fileprivate func applyHeading(in text: String, range: NSRange, level: Int) -> (text: String, cursor: NSRange) {
+    let nsText = text as NSString
+    let lineRange = nsText.lineRange(for: range)
+    let selectedText = nsText.substring(with: lineRange)
+
+    var lines = selectedText.components(separatedBy: "\n")
+    let hadTrailingNewline = lines.last == ""
+    if hadTrailingNewline { lines.removeLast() }
+
+    guard !lines.isEmpty else { return (text, range) }
+
+    let marker = String(repeating: "#", count: max(1, min(level, 3))) + " "
+
+    let updatedLines = lines.map { line -> String in
+        let trimmed = line.trimmingCharacters(in: .whitespaces)
+        guard !trimmed.isEmpty else { return String(line) }
+
+        let withoutHashes = trimmed.drop { $0 == "#" }
+        let stripped = withoutHashes.drop { $0 == " " }
+        return marker + String(stripped)
+    }
+
+    var replacement = updatedLines.joined(separator: "\n")
+    if hadTrailingNewline { replacement.append("\n") }
+
+    let newText = nsText.replacingCharacters(in: lineRange, with: replacement)
+    let location = min(lineRange.location + marker.count, (newText as NSString).length)
+    return (newText, NSRange(location: location, length: 0))
+}
+
+#endif
diff --git a/Yiana/Yiana/Views/PDFViewer.swift b/Yiana/Yiana/Views/PDFViewer.swift
index df783b2..d9b0a43 100644
--- a/Yiana/Yiana/Views/PDFViewer.swift
+++ b/Yiana/Yiana/Views/PDFViewer.swift
@@ -92,7 +92,11 @@ struct PDFKitView: ViewRepresentable {
                         pdfView.go(to: page)
                         context.coordinator.lastReportedPageIndex = clamped
                     }
+                    #if os(iOS)
                     pdfView.documentView?.setNeedsDisplay()
+                    #else
+                    pdfView.documentView?.needsDisplay = true
+                    #endif
                     pdfView.layoutDocumentView()
                     self.totalPages = pageCount
                     if self.currentPage != clamped {
@@ -149,7 +153,11 @@ struct PDFKitView: ViewRepresentable {
                         pdfView.go(to: page)
                         context.coordinator.lastReportedPageIndex = clamped
                     }
+                    #if os(iOS)
                     pdfView.documentView?.setNeedsDisplay()
+                    #else
+                    pdfView.documentView?.needsDisplay = true
+                    #endif
                     pdfView.layoutDocumentView()
                     self.totalPages = pageCount
                     if self.currentPage != clamped {
diff --git a/Yiana/Yiana/Views/TextPageEditorView.swift b/Yiana/Yiana/Views/TextPageEditorView.swift
new file mode 100644
index 0000000..34a253e
--- /dev/null
+++ b/Yiana/Yiana/Views/TextPageEditorView.swift
@@ -0,0 +1,314 @@
+//
+//  TextPageEditorView.swift
+//  Yiana
+//
+//  Created by GPT-5 Codex on 12/01/2026.
+//
+//  High-level SwiftUI wrapper that combines the native Markdown text editor
+//  bridge, preview pane, and toolbar actions. The view adapts between compact
+//  (single column with preview toggle) and regular/wide layouts where editor
+//  and preview sit side-by-side.
+//
+
+import SwiftUI
+#if os(iOS)
+import PDFKit
+#else
+import AppKit
+#endif
+
+struct TextPageEditorView: View {
+    @ObservedObject var viewModel: TextPageEditorViewModel
+    @State private var pendingAction: TextPageEditorAction?
+    @State private var isEditing = false
+
+    #if os(iOS)
+    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
+    @Environment(\.verticalSizeClass) private var verticalSizeClass
+    #endif
+
+    var body: some View {
+        VStack(spacing: 0) {
+            if let recoveredAt = viewModel.recoveredDraftTimestamp {
+                recoveredBanner(date: recoveredAt)
+            }
+
+            editorToolbar
+
+            Divider()
+
+            contentStack
+
+            Divider()
+
+            statusBar
+        }
+        .background(surfaceBackground)
+        .onAppear {
+            adjustPreviewModeForCurrentLayout()
+        }
+        #if os(iOS)
+        .onChange(of: horizontalSizeClass) {
+            adjustPreviewModeForCurrentLayout()
+        }
+        #endif
+        .task {
+            await viewModel.loadDraftIfAvailable()
+        }
+    }
+
+    @ViewBuilder
+    private var contentStack: some View {
+        #if os(iOS)
+        let useSplit = horizontalSizeClass == .regular && verticalSizeClass != .compact
+        if useSplit {
+            splitContent
+        } else {
+            singleColumnContent
+        }
+        #else
+        splitContent
+        #endif
+    }
+
+    private var splitContent: some View {
+        HStack(spacing: 0) {
+            editorPane
+                .frame(maxWidth: .infinity, maxHeight: .infinity)
+
+            Divider()
+
+            previewPane
+                .frame(maxWidth: .infinity, maxHeight: .infinity)
+        }
+    }
+
+    @ViewBuilder
+    private var singleColumnContent: some View {
+        if viewModel.showPreview {
+            previewPane
+        } else {
+            editorPane
+        }
+    }
+
+    private var editorPane: some View {
+        MarkdownTextEditor(
+            text: $viewModel.content,
+            cursorPosition: $viewModel.cursorPosition,
+            pendingAction: $pendingAction,
+            onEditingBegan: { isEditing = true },
+            onEditingEnded: { isEditing = false }
+        )
+        .background(surfaceBackground)
+    }
+
+    private var previewPane: some View {
+        Group {
+            #if os(iOS)
+            if let data = viewModel.latestRenderedPageData,
+               let document = PDFDocument(data: data) {
+                RenderedPagePreview(document: document)
+            } else if let error = viewModel.liveRenderError {
+                VStack(spacing: 8) {
+                    Image(systemName: "exclamationmark.triangle")
+                        .foregroundColor(.orange)
+                    Text(error)
+                        .font(.footnote)
+                        .multilineTextAlignment(.center)
+                        .foregroundColor(.secondary)
+                }
+            } else {
+                VStack(spacing: 12) {
+                    ProgressView()
+                    Text("Rendering previewâ€¦")
+                        .foregroundColor(.secondary)
+                        .font(.footnote)
+                }
+            }
+            #else
+            MarkdownPreview(markdown: viewModel.content)
+            #endif
+        }
+        .background(previewBackground)
+    }
+
+    private var editorToolbar: some View {
+        ScrollView(.horizontal, showsIndicators: false) {
+            HStack(spacing: 16) {
+                toolbarButton(systemName: "bold", label: "Bold") {
+                    pendingAction = .bold
+                }
+
+                toolbarButton(systemName: "italic", label: "Italic") {
+                    pendingAction = .italic
+                }
+
+                Menu {
+                    Button("Heading 1") { pendingAction = .heading(level: 1) }
+                    Button("Heading 2") { pendingAction = .heading(level: 2) }
+                    Button("Heading 3") { pendingAction = .heading(level: 3) }
+                } label: {
+                    Label("Heading", systemImage: "textformat.size")
+                }
+
+                toolbarButton(systemName: "list.bullet", label: "Bulleted list") {
+                    pendingAction = .unorderedList
+                }
+
+                toolbarButton(systemName: "list.number", label: "Numbered list") {
+                    pendingAction = .orderedList
+                }
+
+                toolbarButton(systemName: "text.quote", label: "Quote") {
+                    pendingAction = .blockquote
+                }
+
+                toolbarButton(systemName: "line.horizontal.3", label: "Divider") {
+                    pendingAction = .horizontalRule
+                }
+
+                #if os(iOS)
+                if horizontalSizeClass != .regular || verticalSizeClass == .compact {
+                    Divider().frame(height: 16)
+                    Button {
+                        viewModel.showPreview.toggle()
+                    } label: {
+                        Label(viewModel.showPreview ? "Editor" : "Preview", systemImage: viewModel.showPreview ? "doc.text" : "doc.text.magnifyingglass")
+                    }
+                    .buttonStyle(.plain)
+                }
+                #endif
+            }
+            .padding(.horizontal, 16)
+            .padding(.vertical, 10)
+        }
+        .background(toolbarStripColor)
+    }
+
+    private func toolbarButton(systemName: String, label: String, action: @escaping () -> Void) -> some View {
+        Button(action: action) {
+            Label(label, systemImage: systemName)
+                .labelStyle(.iconOnly)
+                .frame(width: 32, height: 32)
+        }
+        .buttonStyle(.plain)
+        .help(label)
+    }
+
+    private func recoveredBanner(date: Date) -> some View {
+        HStack {
+            Image(systemName: "clock.arrow.circlepath")
+            Text("Recovered draft from \(relativeDateFormatter.localizedString(for: date, relativeTo: Date()))")
+                .font(.footnote)
+            Spacer()
+        }
+        .padding(.horizontal, 16)
+        .padding(.vertical, 8)
+        .background(bannerBackground)
+    }
+
+    private var statusBar: some View {
+        HStack {
+            if case .failed(let error) = viewModel.state {
+                Label(error.localizedDescription, systemImage: "exclamationmark.triangle")
+                    .foregroundColor(.red)
+                    .font(.footnote)
+            } else if let savedAt = viewModel.lastSavedAt {
+                Label("Saved \(relativeDateFormatter.localizedString(for: savedAt, relativeTo: Date()))", systemImage: "checkmark.circle")
+                    .foregroundColor(.secondary)
+                    .font(.footnote)
+            } else {
+                Label(isEditing ? "Editing" : "Ready", systemImage: isEditing ? "pencil" : "doc")
+                    .foregroundColor(.secondary)
+                    .font(.footnote)
+            }
+            Spacer()
+        }
+        .padding(.horizontal, 16)
+        .padding(.vertical, 8)
+    }
+
+    private func adjustPreviewModeForCurrentLayout() {
+        #if os(iOS)
+        if horizontalSizeClass == .regular && verticalSizeClass != .compact {
+            viewModel.showPreview = true
+        }
+        #else
+        viewModel.showPreview = true
+        #endif
+    }
+}
+
+private let relativeDateFormatter: RelativeDateTimeFormatter = {
+    let formatter = RelativeDateTimeFormatter()
+    formatter.unitsStyle = .full
+    return formatter
+}()
+
+private var surfaceBackground: Color {
+#if os(iOS)
+    Color(.systemBackground)
+#else
+    Color(nsColor: .windowBackgroundColor)
+#endif
+}
+
+private var previewBackground: Color {
+#if os(iOS)
+    Color(.secondarySystemBackground)
+#else
+    Color(nsColor: .underPageBackgroundColor)
+#endif
+}
+
+private var toolbarStripColor: Color {
+#if os(iOS)
+    Color(.tertiarySystemBackground)
+#else
+    Color(nsColor: .controlBackgroundColor)
+#endif
+}
+
+private var bannerBackground: Color {
+#if os(iOS)
+    Color(.systemYellow).opacity(0.2)
+#else
+    Color(nsColor: .systemYellow).opacity(0.2)
+#endif
+}
+
+private struct MarkdownPreview: View {
+    var markdown: String
+
+    var body: some View {
+        ScrollView {
+            VStack(alignment: .leading, spacing: 12) {
+                let attributed = TextPageMarkdownFormatter.makePreviewAttributedString(from: markdown)
+                Text(attributed)
+                    .frame(maxWidth: .infinity, alignment: .leading)
+            }
+            .padding(20)
+        }
+    }
+}
+
+#if os(iOS)
+private struct RenderedPagePreview: UIViewRepresentable {
+    let document: PDFDocument
+
+    func makeUIView(context: Context) -> PDFView {
+        let view = PDFView()
+        view.autoScales = true
+        view.displayMode = .singlePage
+        view.displayDirection = .vertical
+        view.backgroundColor = .clear
+        return view
+    }
+
+    func updateUIView(_ uiView: PDFView, context: Context) {
+        uiView.document = document
+        uiView.autoScales = true
+    }
+}
+#endif
diff --git a/Yiana/YianaTests/DocumentMetadataTests.swift b/Yiana/YianaTests/DocumentMetadataTests.swift
index b9b54b7..fb0865e 100644
--- a/Yiana/YianaTests/DocumentMetadataTests.swift
+++ b/Yiana/YianaTests/DocumentMetadataTests.swift
@@ -20,6 +20,7 @@ final class DocumentMetadataTests: XCTestCase {
         let tags = ["important", "work"]
         let ocrCompleted = true
         let fullText = "This is the OCR text content"
+        let hasPendingTextPage = true
         
         // When
         let metadata = DocumentMetadata(
@@ -30,7 +31,8 @@ final class DocumentMetadataTests: XCTestCase {
             pageCount: pageCount,
             tags: tags,
             ocrCompleted: ocrCompleted,
-            fullText: fullText
+            fullText: fullText,
+            hasPendingTextPage: hasPendingTextPage
         )
         
         // Then
@@ -42,6 +44,7 @@ final class DocumentMetadataTests: XCTestCase {
         XCTAssertEqual(metadata.tags, tags)
         XCTAssertEqual(metadata.ocrCompleted, ocrCompleted)
         XCTAssertEqual(metadata.fullText, fullText)
+        XCTAssertTrue(metadata.hasPendingTextPage)
     }
     
     func testDocumentMetadataInitializationWithNilFullText() {
@@ -69,6 +72,7 @@ final class DocumentMetadataTests: XCTestCase {
         // Then
         XCTAssertNil(metadata.fullText)
         XCTAssertFalse(metadata.ocrCompleted)
+        XCTAssertFalse(metadata.hasPendingTextPage)
     }
     
     func testDocumentMetadataEquatable() {
@@ -145,6 +149,7 @@ final class DocumentMetadataTests: XCTestCase {
         XCTAssertEqual(metadata.tags, decodedMetadata.tags)
         XCTAssertEqual(metadata.ocrCompleted, decodedMetadata.ocrCompleted)
         XCTAssertEqual(metadata.fullText, decodedMetadata.fullText)
+        XCTAssertEqual(metadata.hasPendingTextPage, decodedMetadata.hasPendingTextPage)
         
         // Date comparison with tolerance due to encoding/decoding
         XCTAssertEqual(metadata.created.timeIntervalSince1970, decodedMetadata.created.timeIntervalSince1970, accuracy: 1.0)
@@ -166,5 +171,6 @@ final class DocumentMetadataTests: XCTestCase {
         
         // Then
         XCTAssertTrue(metadata.tags.isEmpty)
+        XCTAssertFalse(metadata.hasPendingTextPage)
     }
-}
\ No newline at end of file
+}
diff --git a/Yiana/YianaTests/TextPageMarkdownFormatterTests.swift b/Yiana/YianaTests/TextPageMarkdownFormatterTests.swift
new file mode 100644
index 0000000..5442d9c
--- /dev/null
+++ b/Yiana/YianaTests/TextPageMarkdownFormatterTests.swift
@@ -0,0 +1,135 @@
+import XCTest
+#if os(iOS)
+import UIKit
+#else
+import AppKit
+#endif
+@testable import Yiana
+
+final class TextPageMarkdownFormatterTests: XCTestCase {
+
+    func testPlainTextStripsMarkdownMarkers() {
+        let styles = makeStyles()
+        let result = TextPageMarkdownFormatter.makePDFBody(
+            from: "Heading\n\n**Bold** text with *italic* and `code`.",
+            styles: styles
+        )
+
+        XCTAssertEqual(result.plainText, "Heading\n\nBold text with italic and code.")
+    }
+
+    func testAttributedTextAppliesExpectedFonts() {
+        let styles = makeStyles()
+        let result = TextPageMarkdownFormatter.makePDFBody(
+            from: "Mix **bold** and *italic* plus `code`.",
+            styles: styles
+        )
+
+        let attributed = result.attributed
+        let nsString = attributed.string as NSString
+
+        let boldRange = nsString.range(of: "bold")
+        XCTAssertNotEqual(boldRange.location, NSNotFound)
+        if let font = attributed.attribute(.font, at: boldRange.location, effectiveRange: nil) as? PlatformFont {
+            XCTAssertTrue(fontHasTrait(font, trait: boldTrait()), "Bold segment should use a bold font")
+        } else {
+            XCTFail("Missing font attribute for bold text")
+        }
+
+        let italicRange = nsString.range(of: "italic")
+        XCTAssertNotEqual(italicRange.location, NSNotFound)
+        if let font = attributed.attribute(.font, at: italicRange.location, effectiveRange: nil) as? PlatformFont {
+            XCTAssertTrue(fontHasTrait(font, trait: italicTrait()), "Italic segment should use an italic font")
+        } else {
+            XCTFail("Missing font attribute for italic text")
+        }
+
+        let codeRange = nsString.range(of: "code")
+        XCTAssertNotEqual(codeRange.location, NSNotFound)
+        if let font = attributed.attribute(.font, at: codeRange.location, effectiveRange: nil) as? PlatformFont {
+            XCTAssertTrue(fontMatchesMono(font, mono: styles.monoFont), "Inline code should use the mono font")
+        } else {
+            XCTFail("Missing font attribute for code text")
+        }
+    }
+
+    func testListPlainTextUsesBulletPrefix() {
+        let styles = makeStyles()
+        let result = TextPageMarkdownFormatter.makePDFBody(
+            from: "- First item\n- Second item",
+            styles: styles
+        )
+
+        XCTAssertEqual(result.plainText, "â€¢ First item\nâ€¢ Second item")
+    }
+
+    func testHorizontalRuleProducesLineCharacters() {
+        let styles = makeStyles()
+        let result = TextPageMarkdownFormatter.makePDFBody(
+            from: "Before\n\n---\n\nAfter",
+            styles: styles
+        )
+
+        let lines = result.attributed.string.components(separatedBy: "\n")
+        XCTAssertTrue(lines.contains(where: { $0.trimmingCharacters(in: .whitespaces).hasPrefix("\u{2500}") }), "Horizontal rule should render as box drawing characters")
+    }
+
+    // MARK: - Helpers
+
+    private func makeStyles() -> TextPageMarkdownFormatter.Styles {
+        let typography = TextPageTypography.current()
+        return TextPageMarkdownFormatter.Styles(
+            bodyFont: typography.bodyFont,
+            headingFonts: typography.headingFonts,
+            boldFont: typography.boldFont,
+            italicFont: typography.italicFont,
+            monoFont: typography.monoFont,
+            bodyColor: typography.bodyColor,
+            secondaryColor: typography.secondaryColor,
+            accentColor: typography.accentColor,
+            lineSpacing: 4,
+            paragraphSpacing: typography.bodyFont.pointSize * 0.6,
+            headingSpacing: typography.bodyFont.pointSize * 0.8,
+            listIndent: 20,
+            blockquoteIndent: 24
+        )
+    }
+
+    private func fontHasTrait(_ font: PlatformFont, trait: FontTrait) -> Bool {
+        #if os(iOS)
+        return font.fontDescriptor.symbolicTraits.contains(trait)
+        #else
+        return font.fontDescriptor.symbolicTraits.contains(trait)
+        #endif
+    }
+
+    private func fontMatchesMono(_ font: PlatformFont, mono: PlatformFont) -> Bool {
+        #if os(iOS)
+        return font.fontDescriptor == mono.fontDescriptor && font.pointSize == mono.pointSize
+        #else
+        return font.fontDescriptor == mono.fontDescriptor && abs(font.pointSize - mono.pointSize) < .ulpOfOne
+        #endif
+    }
+
+    private func boldTrait() -> FontTrait {
+        #if os(iOS)
+        return .traitBold
+        #else
+        return .bold
+        #endif
+    }
+
+    private func italicTrait() -> FontTrait {
+        #if os(iOS)
+        return .traitItalic
+        #else
+        return .italic
+        #endif
+    }
+}
+
+#if os(iOS)
+private typealias FontTrait = UIFontDescriptor.SymbolicTraits
+#else
+private typealias FontTrait = NSFontDescriptor.SymbolicTraits
+#endif
diff --git a/Yiana/YianaTests/TextPageRenderServiceTests.swift b/Yiana/YianaTests/TextPageRenderServiceTests.swift
new file mode 100644
index 0000000..7df20e0
--- /dev/null
+++ b/Yiana/YianaTests/TextPageRenderServiceTests.swift
@@ -0,0 +1,36 @@
+import XCTest
+import PDFKit
+@testable import Yiana
+
+final class TextPageRenderServiceTests: XCTestCase {
+
+    override func setUp() async throws {
+        await TextPageLayoutSettings.shared.setPreferredPaperSize(.a4)
+    }
+
+    func testRenderProducesPDFData() async throws {
+        let service = TextPageRenderService.shared
+        let fixedDate = ISO8601DateFormatter().date(from: "2026-01-12T00:00:00Z") ?? Date()
+        let output = try await service.render(markdown: "# Heading\n\nThis is **bold** text.", on: fixedDate)
+
+        XCTAssertFalse(output.pdfData.isEmpty)
+        XCTAssertTrue(output.plainText.contains("Inserted note"))
+        XCTAssertTrue(output.plainText.contains("Heading"))
+    }
+
+    func testRenderAndAppendAddsPage() async throws {
+        let service = TextPageRenderService.shared
+        let first = try await service.render(markdown: "Initial text body.")
+        let combined = try await service.renderAndAppend(markdown: "Second note body", existingPDFData: first.pdfData)
+
+        XCTAssertFalse(combined.combinedPDF.isEmpty)
+        XCTAssertEqual(combined.addedPages, 1)
+        XCTAssertFalse(combined.renderedPagePDF.isEmpty)
+
+        let pdfDocument = PDFDocument(data: combined.combinedPDF)
+        XCTAssertEqual(pdfDocument?.pageCount, 2)
+        XCTAssertTrue(combined.plainText.contains("Second note body"))
+        let lastPageText = pdfDocument?.page(at: 1)?.string ?? ""
+        XCTAssertTrue(lastPageText.contains("Second note body"))
+    }
+}
diff --git a/check-pdf-in-local-store.py b/check-pdf-in-local-store.py
new file mode 100644
index 0000000..c3cc7b3
--- /dev/null
+++ b/check-pdf-in-local-store.py
@@ -0,0 +1,10 @@
+import pdfplumber
+import os
+
+path = "/Users/rose/Code/Yiana/temp-debug-files/_Debug-Rendered-Text-Page.pdf"
+print("exists:", os.path.exists(path))
+if os.path.exists(path):
+    with pdfplumber.open(path) as pdf:
+        for i, page in enumerate(pdf.pages, 1):
+            print("page", i, "text:")
+            print(page.extract_text())
\ No newline at end of file
diff --git a/check-temp-pdf.py b/check-temp-pdf.py
new file mode 100644
index 0000000..fd281e8
--- /dev/null
+++ b/check-temp-pdf.py
@@ -0,0 +1,11 @@
+import os
+import pdfplumber
+
+path = "/private/var/mobile/Library/Mobile Documents/iCloud~com~vitygas~Yiana/Documents/_Debug-Rendered-Text-Page.pdf"
+print("exists:", os.path.exists(path))
+if os.path.exists(path):
+    with pdfplumber.open(path) as pdf:
+        print("pages:", len(pdf.pages))
+        for i, page in enumerate(pdf.pages, 1):
+            print("page", i, "text:")
+            print(page.extract_text())
\ No newline at end of file
diff --git a/checkpdf.py b/checkpdf.py
new file mode 100644
index 0000000..685559d
--- /dev/null
+++ b/checkpdf.py
@@ -0,0 +1,23 @@
+import sys
+import os
+import pdfplumber
+
+if len(sys.argv) > 1:
+    paths = sys.argv[1:]
+else:
+    paths = [
+        "/private/var/mobile/Library/Mobile Documents/"
+        "iCloud~com~vitygas~Yiana/Documents/_Debug-Rendered-Text-Page.pdf"
+    ]
+
+for path in paths:
+    exists = os.path.exists(path)
+    print('---', path, 'exists:', exists)
+    if not exists:
+        continue
+    with pdfplumber.open(path) as pdf:
+        print('pages:', len(pdf.pages))
+        for i, page in enumerate(pdf.pages, 1):
+            text = page.extract_text()
+            print('page', i, 'text:')
+            print(text)
diff --git a/scripts/DEBUG-PDF-SYNC-README.md b/scripts/DEBUG-PDF-SYNC-README.md
new file mode 100644
index 0000000..6ae663b
--- /dev/null
+++ b/scripts/DEBUG-PDF-SYNC-README.md
@@ -0,0 +1,159 @@
+# Debug PDF Auto-Sync Setup
+
+Automatically copy `_Debug-Rendered-Text-Page.pdf` from iCloud to local directory when it changes.
+
+## Quick Start (Recommended: launchd)
+
+This is the most reliable, native macOS solution. It runs automatically in the background.
+
+```bash
+# Start automatic sync service
+./scripts/setup-debug-pdf-sync.sh start
+
+# Check status
+./scripts/setup-debug-pdf-sync.sh status
+
+# View logs
+./scripts/setup-debug-pdf-sync.sh logs
+
+# Stop service
+./scripts/setup-debug-pdf-sync.sh stop
+```
+
+## How It Works
+
+### Method 1: launchd with WatchPaths (RECOMMENDED)
+- **Pros**: Native macOS, no dependencies, reliable, automatic on login, lightweight
+- **Cons**: None significant
+- **Best for**: Production use, set-it-and-forget-it
+
+The launchd service monitors the specific file and runs the sync script whenever it changes.
+
+**Files**:
+- `/Users/rose/Library/LaunchAgents/com.vitygas.yiana.debug-pdf-sync.plist` - launchd configuration
+- `/Users/rose/Code/Yiana/scripts/sync-debug-pdf.sh` - Copy script
+- `/Users/rose/Code/Yiana/scripts/setup-debug-pdf-sync.sh` - Control script
+- `/Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.log` - Activity log
+
+### Method 2: fswatch (Alternative)
+- **Pros**: More flexible for complex scenarios, visible feedback
+- **Cons**: Requires Homebrew installation, must run in terminal
+- **Best for**: Development/debugging, temporary monitoring
+
+**Setup**:
+```bash
+# Install fswatch
+brew install fswatch
+
+# Or use the setup script
+./scripts/setup-debug-pdf-sync.sh install-fswatch
+
+# Run watcher (stays in foreground)
+./scripts/watch-debug-pdf-fswatch.sh
+```
+
+### Method 3: Manual Sync
+For one-time copies:
+```bash
+./scripts/sync-debug-pdf.sh
+```
+
+## Comparison
+
+| Method | Auto-Start | Background | Dependencies | Setup Complexity |
+|--------|-----------|------------|--------------|------------------|
+| **launchd** | âœ… Yes | âœ… Yes | None | Simple |
+| **fswatch** | âŒ No | âŒ No (terminal) | Homebrew | Simple |
+| **Manual** | âŒ No | N/A | None | Trivial |
+
+## Management Commands
+
+```bash
+# Start sync service (runs on every login)
+./scripts/setup-debug-pdf-sync.sh start
+
+# Stop sync service
+./scripts/setup-debug-pdf-sync.sh stop
+
+# Restart sync service (useful after editing scripts)
+./scripts/setup-debug-pdf-sync.sh restart
+
+# Check if running
+./scripts/setup-debug-pdf-sync.sh status
+
+# Watch logs in real-time
+./scripts/setup-debug-pdf-sync.sh logs
+
+# Manual sync
+./scripts/sync-debug-pdf.sh
+```
+
+## Troubleshooting
+
+### Check if launchd service is running
+```bash
+launchctl list | grep com.vitygas.yiana.debug-pdf-sync
+```
+
+### View logs
+```bash
+# Standard output
+cat /Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.log
+
+# Errors
+cat /Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.error.log
+```
+
+### Force immediate sync
+```bash
+launchctl kickstart -k gui/$(id -u)/com.vitygas.yiana.debug-pdf-sync
+```
+
+### Service not starting?
+1. Check plist syntax: `plutil -lint ~/Library/LaunchAgents/com.vitygas.yiana.debug-pdf-sync.plist`
+2. Check script permissions: `ls -l /Users/rose/Code/Yiana/scripts/sync-debug-pdf.sh`
+3. Check paths exist: `ls -l "/Users/rose/Library/Mobile Documents/iCloud~com~vitygas~Yiana/Documents/_Debug-Rendered-Text-Page.pdf"`
+
+### File not syncing?
+1. Verify source file exists and is being updated
+2. Check launchd service status
+3. Look for errors in error log
+4. Try manual sync to test script: `./scripts/sync-debug-pdf.sh`
+
+## File Paths
+
+- **Source**: `/Users/rose/Library/Mobile Documents/iCloud~com~vitygas~Yiana/Documents/_Debug-Rendered-Text-Page.pdf`
+- **Destination**: `/Users/rose/Code/Yiana/temp-debug-files/_Debug-Rendered-Text-Page.pdf`
+- **Logs**: `/Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.log`
+
+## Uninstall
+
+```bash
+# Stop and remove launchd service
+./scripts/setup-debug-pdf-sync.sh stop
+rm ~/Library/LaunchAgents/com.vitygas.yiana.debug-pdf-sync.plist
+
+# Remove scripts (optional)
+rm -rf /Users/rose/Code/Yiana/scripts/sync-debug-pdf.sh
+rm -rf /Users/rose/Code/Yiana/scripts/watch-debug-pdf-fswatch.sh
+rm -rf /Users/rose/Code/Yiana/scripts/setup-debug-pdf-sync.sh
+```
+
+## Technical Details
+
+### launchd Configuration
+- **WatchPaths**: Monitors specific file for changes
+- **RunAtLoad**: Executes once when service loads (initial sync)
+- **KeepAlive**: false (only runs when file changes, not continuously)
+- **StandardOutPath/StandardErrorPath**: Captures all output to log files
+
+### Why launchd Over Others?
+1. **Native**: Built into macOS, no external dependencies
+2. **Reliable**: Apple's standard for background tasks
+3. **Efficient**: Only runs when file actually changes
+4. **Persistent**: Survives reboots, automatically starts on login
+5. **Debuggable**: Built-in logging and management tools
+
+### fswatch vs launchd
+- **fswatch**: Better for watching directories, complex patterns, temporary monitoring
+- **launchd**: Better for watching specific files, production use, persistent monitoring
diff --git a/scripts/QUICK-START.txt b/scripts/QUICK-START.txt
new file mode 100644
index 0000000..c462d28
--- /dev/null
+++ b/scripts/QUICK-START.txt
@@ -0,0 +1,37 @@
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  DEBUG PDF AUTO-SYNC - QUICK START
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+RECOMMENDED: Use launchd (native macOS, automatic, reliable)
+
+START SERVICE:
+  cd /Users/rose/Code/Yiana
+  ./scripts/setup-debug-pdf-sync.sh start
+
+CHECK STATUS:
+  ./scripts/setup-debug-pdf-sync.sh status
+
+VIEW LOGS:
+  ./scripts/setup-debug-pdf-sync.sh logs
+
+STOP SERVICE:
+  ./scripts/setup-debug-pdf-sync.sh stop
+
+MANUAL SYNC (one-time):
+  ./scripts/sync-debug-pdf.sh
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+WHAT IT DOES:
+Automatically copies this file when it changes:
+  FROM: iCloud/Documents/_Debug-Rendered-Text-Page.pdf
+  TO:   temp-debug-files/_Debug-Rendered-Text-Page.pdf
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+TROUBLESHOOTING:
+  - Run setup-debug-pdf-sync.sh status
+  - Check logs: tail temp-debug-files/debug-pdf-sync.log
+  - Test manual: ./scripts/sync-debug-pdf.sh
+
+See DEBUG-PDF-SYNC-README.md for full documentation
diff --git a/scripts/setup-debug-pdf-sync.sh b/scripts/setup-debug-pdf-sync.sh
new file mode 100755
index 0000000..6bcaf8f
--- /dev/null
+++ b/scripts/setup-debug-pdf-sync.sh
@@ -0,0 +1,76 @@
+#!/bin/bash
+
+# Setup script for debug PDF sync
+# Provides commands to start/stop the sync service
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+LAUNCHD_PLIST="$HOME/Library/LaunchAgents/com.vitygas.yiana.debug-pdf-sync.plist"
+LAUNCHD_LABEL="com.vitygas.yiana.debug-pdf-sync"
+
+show_status() {
+    echo "=== Debug PDF Sync Status ==="
+    if launchctl list | grep -q "$LAUNCHD_LABEL"; then
+        echo "Status: RUNNING"
+        echo ""
+        echo "Recent activity:"
+        tail -10 "/Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.log" 2>/dev/null || echo "No logs yet"
+    else
+        echo "Status: STOPPED"
+    fi
+}
+
+case "$1" in
+    start)
+        echo "Starting debug PDF sync service..."
+        launchctl load "$LAUNCHD_PLIST"
+        echo "Service started. Run '$0 status' to check status."
+        ;;
+
+    stop)
+        echo "Stopping debug PDF sync service..."
+        launchctl unload "$LAUNCHD_PLIST"
+        echo "Service stopped."
+        ;;
+
+    restart)
+        echo "Restarting debug PDF sync service..."
+        launchctl unload "$LAUNCHD_PLIST" 2>/dev/null
+        launchctl load "$LAUNCHD_PLIST"
+        echo "Service restarted."
+        ;;
+
+    status)
+        show_status
+        ;;
+
+    logs)
+        echo "=== Debug PDF Sync Logs ==="
+        echo "Press Ctrl+C to stop watching"
+        tail -f "/Users/rose/Code/Yiana/temp-debug-files/debug-pdf-sync.log"
+        ;;
+
+    install-fswatch)
+        echo "Installing fswatch via Homebrew..."
+        brew install fswatch
+        echo "fswatch installed. You can now use watch-debug-pdf-fswatch.sh"
+        ;;
+
+    *)
+        echo "Debug PDF Sync Manager"
+        echo ""
+        echo "Usage: $0 {start|stop|restart|status|logs|install-fswatch}"
+        echo ""
+        echo "Commands:"
+        echo "  start           - Start the launchd service (automatic sync)"
+        echo "  stop            - Stop the launchd service"
+        echo "  restart         - Restart the launchd service"
+        echo "  status          - Show current status"
+        echo "  logs            - Watch sync logs in real-time"
+        echo "  install-fswatch - Install fswatch for alternative method"
+        echo ""
+        echo "Alternative methods:"
+        echo "  Manual sync:    $SCRIPT_DIR/sync-debug-pdf.sh"
+        echo "  fswatch method: $SCRIPT_DIR/watch-debug-pdf-fswatch.sh"
+        exit 1
+        ;;
+esac
diff --git a/scripts/sync-debug-pdf.sh b/scripts/sync-debug-pdf.sh
new file mode 100755
index 0000000..cb057d8
--- /dev/null
+++ b/scripts/sync-debug-pdf.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+# Sync Debug PDF Script
+# Copies the debug PDF from iCloud to local temp directory
+
+SOURCE="/Users/rose/Library/Mobile Documents/iCloud~com~vitygas~Yiana/Documents/_Debug-Rendered-Text-Page.pdf"
+DEST="/Users/rose/Code/Yiana/temp-debug-files/_Debug-Rendered-Text-Page.pdf"
+
+# Ensure destination directory exists
+mkdir -p "$(dirname "$DEST")"
+
+# Copy file if it exists
+if [ -f "$SOURCE" ]; then
+    cp "$SOURCE" "$DEST"
+    echo "$(date '+%Y-%m-%d %H:%M:%S') - Copied debug PDF from iCloud to local directory"
+    exit 0
+else
+    echo "$(date '+%Y-%m-%d %H:%M:%S') - Source file not found: $SOURCE"
+    exit 1
+fi
diff --git a/scripts/watch-debug-pdf-fswatch.sh b/scripts/watch-debug-pdf-fswatch.sh
new file mode 100755
index 0000000..ceeaae6
--- /dev/null
+++ b/scripts/watch-debug-pdf-fswatch.sh
@@ -0,0 +1,34 @@
+#!/bin/bash
+
+# Watch Debug PDF with fswatch
+# Monitors the iCloud debug PDF and copies it when it changes
+
+SOURCE_DIR="/Users/rose/Library/Mobile Documents/iCloud~com~vitygas~Yiana/Documents"
+SOURCE_FILE="_Debug-Rendered-Text-Page.pdf"
+DEST="/Users/rose/Code/Yiana/temp-debug-files/_Debug-Rendered-Text-Page.pdf"
+SYNC_SCRIPT="/Users/rose/Code/Yiana/scripts/sync-debug-pdf.sh"
+
+# Check if fswatch is installed
+if ! command -v fswatch &> /dev/null; then
+    echo "ERROR: fswatch is not installed"
+    echo "Install with: brew install fswatch"
+    exit 1
+fi
+
+# Ensure destination directory exists
+mkdir -p "$(dirname "$DEST")"
+
+echo "Starting watch on: $SOURCE_DIR/$SOURCE_FILE"
+echo "Destination: $DEST"
+echo "Press Ctrl+C to stop"
+echo ""
+
+# Initial sync
+"$SYNC_SCRIPT"
+
+# Watch for changes and sync
+fswatch -0 -e ".*" -i "\\.pdf$" "$SOURCE_DIR" | while read -d "" event; do
+    if [[ "$event" == *"$SOURCE_FILE"* ]]; then
+        "$SYNC_SCRIPT"
+    fi
+done
diff --git a/temp-debug-files/_Debug-Rendered-Text-Page.pdf b/temp-debug-files/_Debug-Rendered-Text-Page.pdf
new file mode 100644
index 0000000..ed6b117
Binary files /dev/null and b/temp-debug-files/_Debug-Rendered-Text-Page.pdf differ
